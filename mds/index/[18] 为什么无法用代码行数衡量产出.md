# 为什么无法用代码行数衡量产出
2022-07-16


## 问题？
众所周知，程序员的工作产出除了完成各种需求之外，就很难再有一个简单，客观的标准评判他的工作产出，从而实现像销售提成般那样的按劳分配的绩效制度

在一般的公司，有些管理者想作妖的时候，往往就会想统计每个程序员的代码量，从而基于代码量来给每个程序员打绩效，但这显然是可笑的，《神秘的程序员们》也有一期专门讽刺这个的漫画

[漫画示例](/18_example.png)

这里问题潜藏的是另一个问题，为什么我们的总是推崇更加抽象的代码，更加通用的架构设计 ？直接说我的想法，那就是抽象的代码的生产力比具象代码更高，因为抽象代码的“可能性”更高，能解决更多的现实问题

可以尝试用数学函数的角度来推理一下

## 数学函数
数学里的函数是由连续的点组成，所以抽象程度高低的就是数学函数所包含的点数

y = { 0,  1 }  就只能代表2个点，而 y = x，就是可以包含这条斜线上的无数个点，明显后者的抽象程度更高

反推到我们的日常的代码， 最简单的例子：
```javascript
// 方法1
function foo (prop) {
  return {
    name: 'fooObj',
    value: prop === 'foo'
  }
}
// 方法2
function foo2 (props) {
  return {
    name: 'fooObj',
    ...props,
  }
}
```

很明显方法2的抽象程度更高，因为方法2可以适配更多的情况，而方法1就相对固化。因为通过简单的有限的几组传参我们就能知道，

- 方法1：只能有1个参数，2个返回结果，
- 方法2：可以有无数个返回结果，并且这些无数结果里包含了方法1的，

从这个论证里就能得知我们衡量抽象的其中一个标准就是：一组代码在运行时能够映射出的静态代码的数量，数量越多，就约抽象

```javascript
function add1 (a) {
  return a + 1
}

function add2 (a, b = 1) {
  return a + b
}
```
如果能把上面的函数，用number数字填充并展开，生成静态，add2多出add1，至少多出 （b - 1）行，所以add2 抽象程度更高

当然实际的开发过程中的代码比上面的示例复杂了非常多，还有各种语言特性，设计模式等，一个抽象函数能够映射出的静态代码几乎是不可衡量，只能各种最佳实践的参考，理论的推理，以及凭借程序员技术的感觉来判断，这是一个极其复杂的过程

所以除非这么一个AI，它可以识别出每个抽象函数的映射，甚至可以再简单一点，它能对比任意2个函数的抽象程度的大小，这时候就也许就能实现用代码给程序员打绩效了。但是用屁股想都能知道，这个能“理解”抽象的AI得有多厉害，拿来做这个事情，实在太小儿科了。

但是谁能说的准呢，毕竟几十年前的计算机科学家们也想不到在机器性能成千上万倍的爆炸之后最主要的用途之一是用来看美女跳舞
