# 数据库"全量”索引
2022-04-28

在了解了一些服务端的高并发问题看到的，大部分都因为数据库会成为性能瓶颈，或者某些服务成为单点问题也<br />是因为数据库。换句话说，有没有办法直接解决数据库的性能瓶颈问题

- 数据库总是瓶颈
   - 为什么数据库不能随意扩容
   - 分布式系统的缺陷：CAP 定理
- 为什么不给数据库的数据建索引和缓存
   - 按需缓存，手动实现
   - 全量索引的存储空间是指数级爆炸
- 自动100%按需缓存
   - 现有的开发模式是假定完全无信任
      - 数据库/服务端系统的输入无法预测
      - 面向未来拓展需要
   - roi，只有量大之后缓存才划算
      - 缓存的成本固定，扩容的成本线性，2者产生交叉后用缓存才划算
   - 是否缓存，实时性
      - 依赖业务的需求来判断
- 重复计算问题
   - 即时是完全相同的请求还是要耗费服务端计算和数据库查询
- 纯函数的可能性
   - 100%的覆盖度
   - 输入可预测，可枚举


## 人对数据的意图
要想实现输入的可预测，必须能够全部枚举产品在面向用户的都提供哪些数据功能，如：

- 查询教室的学生数量
- 更新学生的状态，更新教室
- 登录/注册/评论/发布topic
- 引入外部资源

一个产品能提供的数据交互始终是有限的，可枚举，用户在使用产品的使用，他能做的输入操作也是有限，可预测。（ 除了“模糊搜索”的，但像搜索这种非常典型且垂直且通用的场景可以走另一套单独的技术方案）

所以一般的服务端提供的代码也是一个有限的集合，但我们的代码是专注于抽象的，我们在产品的程序开发中强调”抽象”就是为了在有限的代码里去承接尽可能多的功能，从而降低软件研发的成本。“复用”也是，降低的是下次研发的成本

现在的ER提供的只有CRUD以及相关的一些衍生方法，过于抽象，要想实现产品的提供的功能往往需要大量的中间计算。如果能够把中间空白补充上，那不是以后就不用再写基础的接口了，明显是yes，但是站在一个ORM框架的角度来看，这是不可能，因为它知道自己是被什么产品用了，不可能穷举。


## 自定义类型
参考了“存取能力设计”，意图往往跟数据的类型有相关性，在CRUD的基础上还可以加一层基于类型的操作，这个类型诸如有：

- 颜色
- 日期

除了常规的类型之外，还可以拓展自己的复杂类型，这有点类似业务层的底层通用接口
```typescript
findByKey('color').whereIsWarm() // 查找暖色系
findByKey('money').equals('$1') // 查找等值于1美元
findByKey('schoolWorker').equals('teacher') // 找“老师”或班主任，递进关系
```
类型的解释权应该归对应的产品所有，相同的类型在不同的产品有可能对应不同的语义

但类型本身应该具备横向的功能，又能被功能层重新定义

## 功能层抽象
不同于类型的通用，功能层的抽象逻辑往往只注重于当前功能要解决的问题，只存在于整体功能的复用而不会是功能内个别代码的复用
