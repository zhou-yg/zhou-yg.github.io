<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>What!</title>
  <link type="text/css" rel="stylesheet" href="./content.css" />
</head>
<body>
  <header>

  <img src="./logo.jpg" alt="logo" />

  <!-- <span class="slogan">我不知道你在说什么</span> -->

  <div class="navs">
    
      <a href="./index.html" >首页</a>
    
      <a href="./about.html" >关于</a>
      
  </div>

</header>

  <main>

    <a class="a-link" href="#t4" name="t4" >
  <article>
    <div class="markdown-body">
      <p>&lt;a name=&quot;BW6o0&quot;&gt;&lt;/a&gt;</p>
<h1>背景</h1>
<p>由“模型”中心衍生想到的，当我在尝试实践remix时，remix这种完全以form表单为中心，action处理的方式，跟很早之前的MVC（php，java servlet，其中的主要差别在于remix通过编译手段暴露很多中间状态，改善UI渲染，不能说很像，只能说是极其类似。</p>
<p>参考这个方式会突然想到，古典的MVC是很不适合做复杂前端应用的，所以remix也许这样，但为什么不适合</p>
<p>另外前端是从后端里产生的，但是为什么后端要把这个工作分离出来，仅仅是有人说的因为“后端不想干这个脏活累活”吗？</p>
<p>&lt;a name=&quot;cEm3L&quot;&gt;&lt;/a&gt;</p>
<h1>还原一下</h1>
<p>如果不考虑其它因素，真的完全用php可以实现复杂前端应用吗？比如绘图工具，编辑器工具。明显地，应该是可以实现的，</p>
<p>比如把原本的js里的状态变量都设定为数据库表或者redis，每一次用户的行为都会触发form或ajax请求，在controller里处理状态并落库，之前刷新页面，重新读取数据库里的数据，最后渲染到页面</p>
<p>相比现在的前后端分离的模式，在技术唯一的差别：</p>
<ul>
<li>将原本的前端状态持久化到了数据库</li>
<li>确保前端UI是完全受控于数据库</li>
</ul>
<p>那么在这2个条件下，就能用后端实现一个完全复杂的编辑器应用，前端作为视图层需要完全的渲染HTML即可，如果使用form表单来提交数据，确实甚至都不需要js执行</p>
<p>&lt;a name=&quot;pp7LV&quot;&gt;&lt;/a&gt;</p>
<h1>为什么不</h1>
<p>既然上述的方式存在确实可行，但现实是还是发生了拆分了，那到底是什么因素导致的呢？首先看下上面的弊端，统一在一起之后</p>
<ul>
<li>对人
<ul>
<li>素质要求变高，写的人必须同时写MVC</li>
<li>身兼多职，无法深入研究和解决单一领域问题</li>
<li>单点问题，一个人从头撸到尾容易成为瓶颈，工业化生产讲究分工协作，</li>
</ul>
</li>
<li>对事
<ul>
<li>数据冗余，很多用户的临时操作状态都必须存在数据库里，如果要节约资源就加上及时清理机制</li>
<li>体验不流畅，每步操作都必须走网络请求到服务端，链路长，响应时间久</li>
<li>计算资源浪费，状态的流转都必须借助服务端CPU，浪费了用户客户端的计算能力</li>
<li>耦合问题，全流程绑定到了一起，无法局部复用，无法提升后续效率</li>
</ul>
</li>
</ul>
<p>也许还有更多原因，但总结大体是2个因素导致了现状：</p>
<ul>
<li>（降本）节约（服务器）计算资源</li>
<li>（增效）生产效率</li>
</ul>
<p>降本：</p>
<ul>
<li>将临时状态，用户状态转移到前端内存或浏览器缓存，减少存储</li>
<li>状态的切换转移在js里计算，减少计算和网络请求</li>
<li>由于上述的操作，状态的存取都在用户内存里进行，响应加快，也间接的导致了体验变好</li>
</ul>
<p>增效</p>
<ul>
<li>分离产生的分工，专业的人做专业的事情，前后端分别负责V，C和M，在单点里提升专业度和效率</li>
<li>复用成为可能，由于分离后各自成为单独的抽象层，使得层的复用成为可能</li>
</ul>
<p>&lt;a name=&quot;xZo8Q&quot;&gt;&lt;/a&gt;</p>
<h1>边界的产生</h1>
<p>在分离后，并且随着互联网大发展，前后端在各自的领域里狂奔，在今天去区别一个前后端的人已经不是用“编程语言”来区分了，用js或java并不重要，重要前后职能的人在自己领域内的重点问题的探索，思考，实践，如：</p>
<ul>
<li>前端
<ul>
<li>生产力工具：低代码，web ide，富文本编辑器，各类平台</li>
<li>多端程序：DSL，跨多端多平台，小程序，BFF(SSR，serverless函数计算）</li>
<li>传统视图特色：Web GL，A/VR，游戏引擎</li>
</ul>
</li>
<li>后端：
<ul>
<li>计算性能：高并发，大数据，多媒体处理</li>
<li>存储：各种数据库，中间件，缓存，云盘</li>
<li>devops：容器虚拟，云原生</li>
<li>（列举不全，参考阿里云，腾讯云卖的各种产品）</li>
</ul>
</li>
</ul>
<p>以上只是一些举例，当然还有很多没列举到的。由于前后端在区分的边界上已经更注重于问题领域的差别，而不是手段或者工具，所以熟练的掌握一些工具的经验可以帮助我们更好的探索问题域，但不能本末倒置的沉迷在工具里，不需要再问“学react还是vue”这种问题了</p>
<p>&lt;a name=&quot;JhYBX&quot;&gt;&lt;/a&gt;</p>
<h1>回顾一下更早的历史</h1>
<p>在最原始的时期，那时候连后端都没有，古典时期的程序员们就是直接面向数据库（计算机的本地的存储数据）开发，通过接收原始的输入存储，然后通过指令文本打印到命令行界面：</p>
<blockquote>
<p>命令行文本 &lt;--- 程序处理 &lt;--- 存储的数据</p>
</blockquote>
<p>在传统架构下，计算机仅需考虑用户本地的情况下，当互联网产生的时候，C/S架构也产生了，命令行界面的数据不一定来自于本地，也有可能来自于其它ip的计算机，其它ip的作为数据和计算服务提供者，才称作服务器。逐步逐步演进到今天后，随着问题的解决，以及新的问题越来越大越复杂。</p>
<p>为了适应这种变化，职能的分工也就陆续产生了，虽然职能诞生了，但会发现整个程序的基本模式并没有大变化，变化的是每个流程里不断的细化分工，不断提升的是整个系统的计算能力，输出（传输）能力，存储能力</p>
<blockquote>
<p>输出（多端） &lt;--- 中间处理（服务器架构或客户端）&lt;--- 底层数据（集群）</p>
</blockquote>
<p>&lt;a name=&quot;PHbFJ&quot;&gt;&lt;/a&gt;</p>
<h1>面向更极致的未来</h1>
<p>由于基础设施的完善，生产力工具的爆炸，以及人员素质的提升，也许使得一个人已经可以负担足够多的复杂度。想想看，现在写一个登陆系统，博客系统比之前的时代有了多了多的提升。</p>
<p>继续迭代生产力工具，提升抽象，降低对用户的复杂度，使得之前的复杂应用降维成了现在的简单应用。</p>
<p>所以在今天的场景里，也许已经有办法让一个人或一个职能去负担一个完整且复杂的应用，如果有一个种新的工具具备描述一个完整的功能，通过功能的叠加和组合，再去诞生出一个应用。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t3" name="t3" >
  <article>
    <div class="markdown-body">
      <h1>快速理解next.js</h1>
<p>最近尝鲜真正投入在业务场景里使用了下nextjs，但在刚开始用不久，就产生了一个疑问：</p>
<blockquote>
<p>想在next.js 初始启动的时候去连接数据库，应该怎么做呢？</p>
</blockquote>
<p>在参考了官方示例之后（<span class="inner-link"href="https://github.com/vercel/next.js/tree/canary/examples/with-mongodb">https://github.com/vercel/next.js/tree/canary/examples/with-mongodb</span>）</p>
<p>我有点悟了，发现完全误解了nextjs的真正形态，简单来说：nextjs不是一个带了node服务的前端框架，而是一个集成加强型view的node server</p>
<p>上述的疑问背后的真正问题是：我不了解nextjs，我在尝试寻找nextjs的server的“入口”，而实际上nextjs整个就是server</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t2" name="t2" >
  <article>
    <div class="markdown-body">
      <h1>探寻Low Code</h1>
<h2>概览</h2>
<p>low code（包含no code）一种通过提高抽象，隐藏程序细节的方式而设计出来的面向具体业务（领域）的平台工具，其目标一般是提效（原本角色做的更快更不容易出错）或者赋能（能做他们本做不到的事情）</p>
<p>在公司平台里有大大小小不同的low code平台，针对不同的业务域问题，设计了不同的组件，服务系统，接口，可视化界面等等，然后在自己的业务域里不断迭代着</p>
<p>但是这些low code系统在往往只根据具体问题，设计了具体功能，现有的技术进行代码堆砌，最终出来一个“平台” ，但背后的底层抽象却鲜少提及。</p>
<h2>回溯历史</h2>
<p>我们现在每天接触的JavaScript，java等，通通都是称为高级语言，在高级语言之下的是低级语言，如汇编，机器语言。现在已经不再写汇编了，我们已经可以通过更高抽象的高级语言来完成工作，因为这样更加高效也更准确。所以高级语言某种意义上也是一种low code。</p>
<p>但光有在JavaScript还不够，还不够快，通过语言的特性，上面诞生了各种各样的UI框架，vue，react。这些框架也通过更加高级的抽象，改变了前端工程师的开发方式。这也是一种low code。</p>
<p>在UI框架之上，还有更上层的抽象，如remix，next.js等，通过引入服务端的能力，让前端工程师的技术的纵深又深了一步而且学习的成本很低。</p>
<p>可以看到随着时代的发展，在编程界的工具都是不断提升的抽象，而且领域越来越细分
<img src="./2_1.png" alt="抽象层次"></p>
<h2>一个有意思的问题</h2>
<p>问题：搭建系统的搭建系统（高阶搭建系统）是否有存在的意义？</p>
<p>辅助说明：只通过提供 library 的方式不能算高阶搭建系统
抽象程度：高阶搭建系统 &gt;  搭建系统，
问题域范围：高阶搭建系统 &gt; 单个搭建系统，但 高阶搭建系统 &gt;=  子搭建系统的并集</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t1" name="t1" >
  <article>
    <div class="markdown-body">
      <h1>图形开发</h1>
<p>2020-08-10</p>
<p>前端本质是一个图形开发的子类，而图形开发最终，最高级的形态应该就是游戏，3A游戏。</p>
<p>一个成功的游戏应该是要涵盖图形技术，编剧，音乐，美术，交互互动，是各大类型技术的集大成者。图形开发虽然只是其中的一个分支，但它是其它分支表达的出口，就像小数点前面的1。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t0" name="t0" >
  <article>
    <div class="markdown-body">
      <h1>流程化系统设计</h1>
<p>2019-09-15</p>
<h2>描述</h2>
<p>流程化的执行，是一个中心化的调度者。通过流程 + 服务调用的能力，可以把各种各样的服务进行串联的系统。</p>
<h2>节点树 + 执行器</h2>
<p>中心系统的前端UI界面经过用户的意志产生了节点树（Node Tree），上传到系统中，执行器（Runtime）去执行对应的节点树（Node Tree），就像手写js代码，然后放到服务器node环境中执行一样。</p>
<h2>标准服务模块</h2>
<p>中心系统本身基本没有服务的能力，只能执行流程，调用服务。所以外围注册的服务模块的决定了流程系统的上限。就像nodejs调后端接口一样</p>
<p>整个体验的过程就像是可视化编程一样，程序 = 逻辑 + 服务 + 执行</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
  </main>
</body>
<script src="./content-script.js" ></script>
</html>