<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>What!</title>
  <link type="text/css" rel="stylesheet" href="./content.css" />
</head>
<body>
  <header>

  <img src="./logo.jpg" alt="logo" />

  <!-- <span class="slogan">我不知道你在说什么</span> -->

  <div class="navs">
    
      <a href="./index.html" >首页</a>
    
      <a href="./about.html" >关于</a>
      
  </div>

</header>

  <main>

    <a class="a-link" href="#t6" name="t6" >
  <article>
    <div class="markdown-body">
      <h1>小“闭环”体系</h1>
<p>最近在思考前后端一体化单元时，想到了几种形式：框架，或者 语言形式，如果采用语言形式，需要设计一套新的DSL，如果使用声明式DSL，还可以在使用可视化编辑器 + DSL runtime，如果是过程式DSL，可以使用Web IDE 结合 代码生成，出码后得考虑是直接的代码，还是生成包含框架的代码，如果是框架是否可以使用最开始的框架</p>
<p>---- 上层</p>
<ul>
<li>UI
<ul>
<li>计算数据</li>
<li>原始远端数据</li>
</ul>
</li>
<li>serverless 中间抽象层</li>
<li>Model
<ul>
<li>原始数据</li>
<li>高性能缓存的数据</li>
</ul>
</li>
</ul>
<p>---- 下层</p>
<ul>
<li>底层：
<ul>
<li>框架
<ul>
<li>抽象概念</li>
</ul>
</li>
<li>语言
<ul>
<li>抽象概念</li>
</ul>
</li>
</ul>
</li>
<li>我的DSL
<ul>
<li>声明式
<ul>
<li>DSL可视化编辑器</li>
</ul>
</li>
<li>过程式
<ul>
<li>富文本编辑器</li>
</ul>
</li>
</ul>
</li>
<li>出码
<ul>
<li>中间产物 + runtime
<ul>
<li>底层的承接
<ul>
<li>框架</li>
</ul>
</li>
</ul>
</li>
<li>代码生成
<ul>
<li>底层的承接
<ul>
<li>语言</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t5" name="t5" >
  <article>
    <div class="markdown-body">
      <h1>前端的边界</h1>
<blockquote>
<p>探索一下”前端“这个岗位在技术，职能的天花板</p>
</blockquote>
<h2>背景</h2>
<p>由“模型”中心衍生想到的，当我在尝试实践remix时，remix这种完全以form表单为中心，action处理的方式，跟很早之前的MVC（php，java servlet，其中的主要差别在于remix通过编译手段暴露很多中间状态，改善UI渲染，不能说很像，只能说是极其类似。</p>
<p>参考这个方式会突然想到，古典的MVC是很不适合做复杂前端应用的，所以remix也许这样，但为什么不适合</p>
<p>另外前端是从后端里产生的，但是为什么后端要把这个工作分离出来，仅仅是有人说的因为“后端不想干这个脏活累活”吗？</p>
<h2>还原一下</h2>
<p>如果不考虑其它因素，真的完全用php可以实现复杂前端应用吗？比如绘图工具，编辑器工具。明显地，应该是可以实现的，</p>
<p>比如把原本的js里的状态变量都设定为数据库表或者redis，每一次用户的行为都会触发form或ajax请求，在controller里处理状态并落库，之前刷新页面，重新读取数据库里的数据，最后渲染到页面</p>
<p>相比现在的前后端分离的模式，在技术唯一的差别：</p>
<ul>
<li>将原本的前端状态持久化到了数据库</li>
<li>确保前端UI是完全受控于数据库</li>
</ul>
<p>那么在这2个条件下，就能用后端实现一个完全复杂的编辑器应用，前端作为视图层需要完全的渲染HTML即可，如果使用form表单来提交数据，确实甚至都不需要js执行</p>
<h2>为什么不</h2>
<p>既然上述的方式存在确实可行，但现实是还是发生了拆分了，那到底是什么因素导致的呢？首先看下上面的弊端，统一在一起之后</p>
<ul>
<li>对人
<ul>
<li>素质要求变高，写的人必须同时写MVC</li>
<li>身兼多职，无法深入研究和解决单一领域问题</li>
<li>单点问题，一个人从头撸到尾容易成为瓶颈，工业化生产讲究分工协作，</li>
</ul>
</li>
<li>对事
<ul>
<li>数据冗余，很多用户的临时操作状态都必须存在数据库里，如果要节约资源就加上及时清理机制</li>
<li>体验不流畅，每步操作都必须走网络请求到服务端，链路长，响应时间久</li>
<li>计算资源浪费，状态的流转都必须借助服务端CPU，浪费了用户客户端的计算能力</li>
<li>耦合问题，全流程绑定到了一起，无法局部复用，无法提升后续效率</li>
</ul>
</li>
</ul>
<p>也许还有更多原因，但总结大体是2个因素导致了现状：</p>
<ul>
<li>（降本）节约（服务器）计算资源</li>
<li>（增效）生产效率</li>
</ul>
<p>降本：</p>
<ul>
<li>将临时状态，用户状态转移到前端内存或浏览器缓存，减少存储</li>
<li>状态的切换转移在js里计算，减少计算和网络请求</li>
<li>由于上述的操作，状态的存取都在用户内存里进行，响应加快，也间接的导致了体验变好</li>
</ul>
<p>增效</p>
<ul>
<li>分离产生的分工，专业的人做专业的事情，前后端分别负责V，C和M，在单点里提升专业度和效率</li>
<li>复用成为可能，由于分离后各自成为单独的抽象层，使得层的复用成为可能</li>
</ul>
<h2>边界的产生</h2>
<p>在分离后，并且随着互联网大发展，前后端在各自的领域里狂奔，在今天去区别一个前后端的人已经不是用“编程语言”来区分了，用js或java并不重要，重要前后职能的人在自己领域内的重点问题的探索，思考，实践，如：</p>
<ul>
<li>前端
<ul>
<li>生产力工具：低代码，web ide，富文本编辑器，各类平台</li>
<li>多端程序：DSL，跨多端多平台，小程序，BFF(SSR，serverless函数计算）</li>
<li>传统视图特色：Web GL，A/VR，游戏引擎</li>
</ul>
</li>
<li>后端：
<ul>
<li>计算性能：高并发，大数据，多媒体处理</li>
<li>存储：各种数据库，中间件，缓存，云盘</li>
<li>devops：容器虚拟，云原生</li>
<li>（列举不全，参考阿里云，腾讯云卖的各种产品）</li>
</ul>
</li>
</ul>
<p>以上只是一些举例，当然还有很多没列举到的。由于前后端在区分的边界上已经更注重于问题领域的差别，而不是手段或者工具，所以熟练的掌握一些工具的经验可以帮助我们更好的探索问题域，但不能本末倒置的沉迷在工具里，不需要再问“学react还是vue”这种问题了</p>
<h2>回顾一下更早的历史</h2>
<p>在最原始的时期，那时候连后端都没有，古典时期的程序员们就是直接面向数据库（计算机的本地的存储数据）开发，通过接收原始的输入存储，然后通过指令文本打印到命令行界面：</p>
<blockquote>
<p>命令行文本 &lt;--- 程序处理 &lt;--- 存储的数据</p>
</blockquote>
<p>在传统架构下，计算机仅需考虑用户本地的情况下，当互联网产生的时候，C/S架构也产生了，命令行界面的数据不一定来自于本地，也有可能来自于其它ip的计算机，其它ip的作为数据和计算服务提供者，才称作服务器。逐步逐步演进到今天后，随着问题的解决，以及新的问题越来越大越复杂。</p>
<p>为了适应这种变化，职能的分工也就陆续产生了，虽然职能诞生了，但会发现整个程序的基本模式并没有大变化，变化的是每个流程里不断的细化分工，不断提升的是整个系统的计算能力，输出（传输）能力，存储能力</p>
<blockquote>
<p>输出（多端） &lt;--- 中间处理（服务器架构或客户端）&lt;--- 底层数据（集群）</p>
</blockquote>
<h2>面向更极致的未来</h2>
<p>由于基础设施的完善，生产力工具的爆炸，以及人员素质的提升，也许使得一个人已经可以负担足够多的复杂度。想想看，现在写一个登陆系统，博客系统比之前的时代有了多了多的提升。</p>
<p>继续迭代生产力工具，提升抽象，降低对用户的复杂度，使得之前的复杂应用降维成了现在的简单应用。</p>
<p>所以在今天的场景里，也许已经有办法让一个人或一个职能去负担一个完整且复杂的应用，如果有一个种新的工具具备描述一个完整的功能，通过功能的叠加和组合，再去诞生出一个应用。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t4" name="t4" >
  <article>
    <div class="markdown-body">
      <h1>以“模型”为中心</h1>
<blockquote>
<p>不想再写一次登录系统了</p>
</blockquote>
<h2>Nextjs</h2>
<p>深度使用nextjs后的感悟，发现nextjs这种以serverless为中心的设计复用的，以路由即页面</p>
<p>这样的问题是由于serverless缺少模型的信息，导致在业务逻辑就只能在前端UI的逻辑里面处理，同时在设计时，需要区分前端的状态和模型的字段</p>
<p>这导致的一个问题，设计书写一个完整功能是被分割成了3个地方：ER模型，serverless或前端处理逻辑，UI</p>
<p>在架构上就处于3横多纵的模式，这样的好处是相同层容易互相复用逻辑（耦合），局部的横向造成了耦合，但却无法整体导出</p>
<p>如果以模型为中心，只构建纵向，横向的建联通过直接的引用。</p>
<pre><code class="language-typescript">// module2.jsx
import { useApi: useApi1, Component } from 'module1.jsx'

export function useApi () {
  const use1 = useApi1()
  return {
    findFoo () {    
      use1.findAndDoSomething('')
    }
  }
}

export function Component () {
  return (
    &lt;newDialog&gt;
      &lt;Component /&gt;
    &lt;/newDialog&gt;
  )
}
</code></pre>
<p>这样的模型，severless，UI为组合，那就像之前的MVC架构， M -&gt; C -&gt; V -&gt; C -&gt; M的流程</p>
<p>这里有个问题，当M -&gt; C -&gt; V之后，其实在V层面已经收到了来自于C层经过计算之后得到的状态，为什么当状态修改的时候，还需要显示的调用 V -&gt; C -&gt; M 把数据再还原回去呢，为什么不能逆向计算后，直接 V -&gt; M？</p>
<ul>
<li>不是所有的计算都是可逆的，那哪些计算可逆？</li>
<li>也不是所有的V都需要直接到M，有些是临时状态需要缓存，如何显示的区分这些状态</li>
</ul>
<h3>发散</h3>
<p>http server 是无状态的或者只缓存状态，模型里只保存最原始的数据或者为了性能考虑保存需要大量计算的数据或索引</p>
<ul>
<li>怎么判断哪些状态字段需要持久到模型中？
<ul>
<li>如状态不存在模型中，那么模型到状态之间总是需要一个计算，好像是serverless不可缺少？</li>
</ul>
</li>
<li>“状态”如何在 server/website 中同步 ？</li>
</ul>
<h2>前后一体化单元</h2>
<p>实现一个功能最小单位至少包含：UI，serverless或useHook，Model ，（其中UI和model至少有1个）</p>
<blockquote>
<p>另外的场景：单独的后端很少会讲到复用，但当说到复用的时候，系统负责的领域足够大时，这就成了“中台”</p>
</blockquote>
<ul>
<li>没有Model
<ul>
<li>静态站点，博客</li>
<li>Sketch，PS工具（广义来说，ps文件作为输入，也应视作Model）</li>
</ul>
</li>
<li>没有UI
<ul>
<li>API gateway（这种是中间件，这个好像Model也没有，但这个不够广泛</li>
<li>CDN服务，Open API服务，各种后端服务系统</li>
</ul>
</li>
</ul>
<p>在不考虑“用户”的情况：Model最重要，数据是资产&lt;br /&gt;在考虑“用户”的情况下：UI最重要，能用和好用</p>
<p>一体化单元之间的互相组合有2种形式：</p>
<ul>
<li>静态，需要版本管理
<ul>
<li>就像类库的引入，之后2个单元就是相同的工程，
<ul>
<li>问题：model层是一个大集合，同时无法拆分，存储成本</li>
</ul>
</li>
</ul>
</li>
<li>动态，需要运行时
<ul>
<li>就像微服务或中台，引入的其实是SDK，2个单元不能算是一个有机的整体，只是允许互相调用的服务
<ul>
<li>问题：model层会成为单点</li>
</ul>
</li>
<li>一旦动态之后就需要：服务的发现，注册，订阅，销毁等生命周期，</li>
</ul>
</li>
</ul>
<p>一体化单元要暴露的是：</p>
<ul>
<li>Serverless或hook</li>
<li>UI</li>
</ul>
<p>微服务</p>
<ul>
<li>持久层隔离
<ul>
<li>底层Model之间的关系的引用和处理，跨数据库，这个怎么索引和建联？</li>
</ul>
</li>
<li>公用Model
<ul>
<li>单点问题</li>
<li>大表索引问题</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t3" name="t3" >
  <article>
    <div class="markdown-body">
      <h1>快速理解next.js</h1>
<p>最近尝鲜真正投入在业务场景里使用了下nextjs，但在刚开始用不久，就产生了一个疑问：</p>
<blockquote>
<p>想在next.js 初始启动的时候去连接数据库，应该怎么做呢？</p>
</blockquote>
<p>在参考了官方示例之后（<span class="inner-link"href="https://github.com/vercel/next.js/tree/canary/examples/with-mongodb">https://github.com/vercel/next.js/tree/canary/examples/with-mongodb</span>）</p>
<p>我有点悟了，发现完全误解了nextjs的真正形态，简单来说：nextjs不是一个带了node服务的前端框架，而是一个集成加强型view的node server</p>
<p>上述的疑问背后的真正问题是：我不了解nextjs，我在尝试寻找nextjs的server的“入口”，而实际上nextjs整个就是server</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t2" name="t2" >
  <article>
    <div class="markdown-body">
      <h1>探寻Low Code</h1>
<h2>概览</h2>
<p>low code（包含no code）一种通过提高抽象，隐藏程序细节的方式而设计出来的面向具体业务（领域）的平台工具，其目标一般是提效（原本角色做的更快更不容易出错）或者赋能（能做他们本做不到的事情）</p>
<p>在公司平台里有大大小小不同的low code平台，针对不同的业务域问题，设计了不同的组件，服务系统，接口，可视化界面等等，然后在自己的业务域里不断迭代着</p>
<p>但是这些low code系统在往往只根据具体问题，设计了具体功能，现有的技术进行代码堆砌，最终出来一个“平台” ，但背后的底层抽象却鲜少提及。</p>
<h2>回溯历史</h2>
<p>我们现在每天接触的JavaScript，java等，通通都是称为高级语言，在高级语言之下的是低级语言，如汇编，机器语言。现在已经不再写汇编了，我们已经可以通过更高抽象的高级语言来完成工作，因为这样更加高效也更准确。所以高级语言某种意义上也是一种low code。</p>
<p>但光有在JavaScript还不够，还不够快，通过语言的特性，上面诞生了各种各样的UI框架，vue，react。这些框架也通过更加高级的抽象，改变了前端工程师的开发方式。这也是一种low code。</p>
<p>在UI框架之上，还有更上层的抽象，如remix，next.js等，通过引入服务端的能力，让前端工程师的技术的纵深又深了一步而且学习的成本很低。</p>
<p>可以看到随着时代的发展，在编程界的工具都是不断提升的抽象，而且领域越来越细分
<img src="./2_1.png" alt="抽象层次"></p>
<h2>一个有意思的问题</h2>
<p>问题：搭建系统的搭建系统（高阶搭建系统）是否有存在的意义？</p>
<p>辅助说明：只通过提供 library 的方式不能算高阶搭建系统
抽象程度：高阶搭建系统 &gt;  搭建系统，
问题域范围：高阶搭建系统 &gt; 单个搭建系统，但 高阶搭建系统 &gt;=  子搭建系统的并集</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t1" name="t1" >
  <article>
    <div class="markdown-body">
      <h1>图形开发</h1>
<p>2020-08-10</p>
<p>前端本质是一个图形开发的子类，而图形开发最终，最高级的形态应该就是游戏，3A游戏。</p>
<p>一个成功的游戏应该是要涵盖图形技术，编剧，音乐，美术，交互互动，是各大类型技术的集大成者。图形开发虽然只是其中的一个分支，但它是其它分支表达的出口，就像小数点前面的1。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t0" name="t0" >
  <article>
    <div class="markdown-body">
      <h1>流程化系统设计</h1>
<p>2019-09-15</p>
<h2>描述</h2>
<p>流程化的执行，是一个中心化的调度者。通过流程 + 服务调用的能力，可以把各种各样的服务进行串联的系统。</p>
<h2>节点树 + 执行器</h2>
<p>中心系统的前端UI界面经过用户的意志产生了节点树（Node Tree），上传到系统中，执行器（Runtime）去执行对应的节点树（Node Tree），就像手写js代码，然后放到服务器node环境中执行一样。</p>
<h2>标准服务模块</h2>
<p>中心系统本身基本没有服务的能力，只能执行流程，调用服务。所以外围注册的服务模块的决定了流程系统的上限。就像nodejs调后端接口一样</p>
<p>整个体验的过程就像是可视化编程一样，程序 = 逻辑 + 服务 + 执行</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
  </main>
</body>
<script src="./content-script.js" ></script>
</html>