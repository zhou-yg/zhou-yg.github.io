<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>What!</title>
  <link type="text/css" rel="stylesheet" href="./content.css" />
</head>
<body>
  <header>

  <img src="./logo.jpg" alt="logo" />

  <!-- <span class="slogan">我不知道你在说什么</span> -->

  <div class="navs">
    
      <a href="./index.html" >首页</a>
    
      <a href="./about.html" >关于</a>
      
  </div>

</header>

  <main>

    <a class="a-link" href="#t10" name="t10" >
  <article>
    <div class="markdown-body">
      <h1>数据库&quot;全量”索引</h1>
<p>2022-04-28</p>
<p>在了解了一些服务端的高并发问题看到的，大部分都因为数据库会成为性能瓶颈，或者某些服务成为单点问题也&lt;br /&gt;是因为数据库。换句话说，有没有办法直接解决数据库的性能瓶颈问题</p>
<ul>
<li>数据库总是瓶颈
<ul>
<li>为什么数据库不能随意扩容</li>
<li>分布式系统的缺陷：CAP 定理</li>
</ul>
</li>
<li>为什么不给数据库的数据建索引和缓存
<ul>
<li>按需缓存，手动实现</li>
<li>全量索引的存储空间是指数级爆炸</li>
</ul>
</li>
<li>自动100%按需缓存
<ul>
<li>现有的开发模式是假定完全无信任
<ul>
<li>数据库/服务端系统的输入无法预测</li>
<li>面向未来拓展需要</li>
</ul>
</li>
<li>roi，只有量大之后缓存才划算
<ul>
<li>缓存的成本固定，扩容的成本线性，2者产生交叉后用缓存才划算</li>
</ul>
</li>
<li>是否缓存，实时性
<ul>
<li>依赖业务的需求来判断</li>
</ul>
</li>
</ul>
</li>
<li>重复计算问题
<ul>
<li>即时是完全相同的请求还是要耗费服务端计算和数据库查询</li>
</ul>
</li>
<li>纯函数的可能性
<ul>
<li>100%的覆盖度</li>
<li>输入可预测，可枚举</li>
</ul>
</li>
</ul>
<h1>人对数据的意图</h1>
<p>要想实现输入的可预测，必须能够全部枚举产品在面向用户的都提供哪些数据功能，如：</p>
<ul>
<li>查询教室的学生数量</li>
<li>更新学生的状态，更新教室</li>
<li>登录/注册/评论/发布topic</li>
<li>引入外部资源</li>
</ul>
<p>一个产品能提供的数据交互始终是有限的，可枚举，用户在使用产品的使用，他能做的输入操作也是有限，可预测。（ 除了“模糊搜索”的，但像搜索这种非常典型且垂直且通用的场景可以走另一套单独的技术方案）</p>
<p>所以一般的服务端提供的代码也是一个有限的集合，但我们的代码是专注于抽象的，我们在产品的程序开发中强调”抽象”就是为了在有限的代码里去承接尽可能多的功能，从而降低软件研发的成本。“复用”也是，降低的是下次研发的成本</p>
<p>现在的ER提供的只有CRUD以及相关的一些衍生方法，过于抽象，要想实现产品的提供的功能往往需要大量的中间计算。如果能够把中间空白补充上，那不是以后就不用再写基础的接口了，明显是yes，但是站在一个ORM框架的角度来看，这是不可能，因为它知道自己是被什么产品用了，不可能穷举。</p>
<h1>自定义类型</h1>
<p>参考了“存取能力设计”，意图往往跟数据的类型有相关性，在CRUD的基础上还可以加一层基于类型的操作，这个类型诸如有：</p>
<ul>
<li>颜色</li>
<li>日期</li>
</ul>
<p>除了常规的类型之外，还可以拓展自己的复杂类型，这有点类似业务层的底层通用接口</p>
<pre><code class="language-typescript">findByKey('color').whereIsWarm() // 查找暖色系
findByKey('money').equals('$1') // 查找等值于1美元
findByKey('schoolWorker').equals('teacher') // 找“老师”或班主任，递进关系
</code></pre>
<p>类型的解释权应该归对应的产品所有，相同的类型在不同的产品有可能对应不同的语义</p>
<p>但类型本身应该具备横向的功能，又能被功能层重新定义</p>
<h1>功能层抽象</h1>
<p>不同于类型的通用，功能层的抽象逻辑往往只注重于当前功能要解决的问题，只存在于整体功能的复用而不会是功能内个别代码的复用</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t9" name="t9" >
  <article>
    <div class="markdown-body">
      <h1>一个用户值多少钱</h1>
<p>2022-03-01</p>
<p>在互联网有这么一群人，他们不发帖不评论，几乎不生产任何内容，他们在网上留下的最重的动作可能就只是“点赞”和“关注”，很多从业者把这群人称作白嫖用户，他们在网上微不足道，但聚在一起却成了所有互联人求知若渴的“流量”</p>
<p>所以这里就有一个很矛盾的点，对于商业主体而言：</p>
<ul>
<li>成本
<ul>
<li>为了服务大量的普通用户，服务器成了大量的开销，是一个巨大负担</li>
</ul>
</li>
<li>利益
<ul>
<li>大量的普通用户汇聚在一起之后成了公司不可或缺的流量，公司需要这股流量进行变现，获得收入</li>
</ul>
</li>
</ul>
<p>经典的极端的2个方向，有矛盾那就说明有“边界”，越过这个“边界”让普通用户具备了超过“成本”的商业价值，使得商业主体获得利润</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t8" name="t8" >
  <article>
    <div class="markdown-body">
      <h1>小“闭环”体系</h1>
<p>2022-04-11</p>
<p>最近在思考前后端一体化单元时，想到了几种形式：框架，或者 语言形式，如果采用语言形式，需要设计一套新的DSL，如果使用声明式DSL，还可以在使用可视化编辑器 + DSL runtime，如果是过程式DSL，可以使用Web IDE 结合 代码生成，出码后得考虑是直接的代码，还是生成包含框架的代码，如果是框架是否可以使用最开始的框架</p>
<p>---- 上层</p>
<ul>
<li>UI
<ul>
<li>计算数据</li>
<li>原始远端数据</li>
</ul>
</li>
<li>serverless 中间抽象层</li>
<li>Model
<ul>
<li>原始数据</li>
<li>高性能缓存的数据</li>
</ul>
</li>
</ul>
<p>---- 下层</p>
<ul>
<li>底层：
<ul>
<li>框架
<ul>
<li>抽象概念</li>
</ul>
</li>
<li>语言
<ul>
<li>抽象概念</li>
</ul>
</li>
</ul>
</li>
<li>我的DSL
<ul>
<li>声明式
<ul>
<li>DSL可视化编辑器</li>
</ul>
</li>
<li>过程式
<ul>
<li>富文本编辑器</li>
</ul>
</li>
</ul>
</li>
<li>出码
<ul>
<li>中间产物 + runtime
<ul>
<li>底层的承接
<ul>
<li>框架</li>
</ul>
</li>
</ul>
</li>
<li>代码生成
<ul>
<li>底层的承接
<ul>
<li>语言</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t7" name="t7" >
  <article>
    <div class="markdown-body">
      <h1>关注&quot;读&quot;数据</h1>
<p>2022-04-24</p>
<p>原始的ORM是数据库的操作的映射，现在更进一步发展了像prisma这样的基于ER的操作，但是原始的CRUD和关联关系还是不够描述</p>
<p>在实现”版本“的过程中发现
写操作，可以针对id进行原子化操作，即写操作必须是完全建立“读”的基础上
读操作，才需要重点考虑各种复杂的拓展关系，既要满足查询的诉求，同时也要作为“写”操作的基础</p>
<p>读操作（R）可以拆解成几个步骤：
● 参数	
○ 必须是精确描述
○ 参数 不等于 “意图”
○ “函数”处理：求和，排序等
● 运行查询
○ 根据“Entity”来找数据
○ 同时兼处理“函数”
● 给出查询结果</p>
<p>读（R）操作附带有查询和处理，由于现在的数据库都默认自带了一些“函数”逻辑，如排序，合并，所以很难意识到处理的部分，假设数据库不带这些函数，那么用户就必须在给出查询结果，再用额外的函数进行手动处理，手动处理的部分也是意图的一部分</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t6" name="t6" >
  <article>
    <div class="markdown-body">
      <h1>“搭建系统”的困境和突破</h1>
<p>2021-12-31</p>
<p>搭建系统是工具，工具是解决问题的，所以重点关注问题是什么，为什么搭建系统能解决。&lt;br /&gt;第二关注工具是怎么解决问题的，解决的结果如何。&lt;br /&gt;以及最后的剩下无法解决的问题怎么办？还有办法能解决吗？</p>
<p>基本纲要</p>
<ul>
<li>对齐认知
<ul>
<li>同步“目标”
<ul>
<li>业务
<ul>
<li>快速上线</li>
</ul>
</li>
<li>技术
<ul>
<li>原子化，沉淀复用</li>
<li>原子组件的开发体验要好：少概念，渐进增强</li>
</ul>
</li>
</ul>
</li>
<li>同步“搭建系统”的概念，定义，特点
<ul>
<li>面向非技术为主</li>
<li>NoCode</li>
<li>不需要可维护性</li>
</ul>
</li>
<li>同步个人的简单经历
<ul>
<li>美店</li>
<li>蚂蚁营销工作台</li>
</ul>
</li>
</ul>
</li>
<li>代入问题
<ul>
<li>能解决的问题域太小太垂直
<ul>
<li>有限的输入和组合只能解决更加有限的问题</li>
</ul>
</li>
<li>受上游影响极大
<ul>
<li>问题域内的是神器，问题域外的一文不值甚至负作用</li>
</ul>
</li>
</ul>
</li>
<li>对破局的思考
<ul>
<li>解决方向
<ul>
<li>广度
<ul>
<li>原子化，提升抽象，-&gt; 重新发明html，css，js</li>
</ul>
</li>
<li>深度
<ul>
<li>业务
<ul>
<li>需求不可控 -&gt; 需求全部适配 -&gt; 人力填坑 -&gt; 拓展边界 -&gt; 广度问题</li>
</ul>
</li>
<li>技术
<ul>
<li>极大增加搭建系统的数量 -&gt; 提升搭建系统的开发效率 -&gt; 搭建系统的搭建系统 -&gt; 搭建系统的基础物料 + 问题域定制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>换个角度
<ul>
<li>卷往上游，以需求逻辑为中心
<ul>
<li>需求逻辑的描述是必须的，核心的，稳定的</li>
<li>需求逻辑是可流程化描述，如流程图</li>
<li>基于逻辑是可自动化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>落地的结局
<ul>
<li>落地的困难
<ul>
<li>no，low，pro code之间的差异</li>
</ul>
</li>
<li>和解，放弃完全的NoCode，工程师你回来吧
<ul>
<li>重点解决其中的需求的确定性的部分
<ul>
<li>需求的确定性越高，需求的信息量就越大，编写程序就变得越简单，后续而二次消费也更容易</li>
<li>确定边界</li>
</ul>
</li>
<li>流程图变成填空题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>为什么搭建</h1>
<p>C端营销场景：技术服务业务，业务KPI。</p>
<ul>
<li>目标：业务KPI
<ul>
<li>承接：页面</li>
<li>目标：快速上线
<ul>
<li>承接：技术</li>
<li>目标：页面开发效率 （ 效率 = 工程师  * 页面代码 / 时间）
<ul>
<li>时间不变，提升工程师，提升页面代码</li>
<li>目标1：提升工程师
<ul>
<li>工程师很难提升，只能转移或者赋能
<ul>
<li>转到外包</li>
<li>降低门槛，让非工程师也能做</li>
</ul>
</li>
</ul>
</li>
<li>目标2：提升页面代码
<ul>
<li>代码不能凭空产生，要么由人(AI)编写，要么使用已经存在的代码
<ul>
<li>AI手段：各种 to code，Design to Code, Prd to Code, Flow to Code</li>
<li>代码封装，复用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>页面搭建系统是符合上述的2个目标的解决方案之一</p>
<h1>问题域</h1>
<p>搭建工具对应的问题域的特征：</p>
<ul>
<li>技术挑战类：
<ul>
<li>流量大，时效性强
<ul>
<li>活动特征，跟随大促节点</li>
<li>读远大于写入</li>
</ul>
</li>
<li>状态简单
<ul>
<li>流转关系可以通过逻辑流程图充分描述，并被一般人充分理解</li>
<li>状态枚举通常不会超过3个值（如 0/1, 0/pending/1,  pending/fulfiled/rejected）</li>
</ul>
</li>
</ul>
</li>
<li>业务价值类
<ul>
<li>无序
<ul>
<li>缺少统一标准（技术标准，产品标准）</li>
<li>缺少最佳实践，</li>
<li>反复验证，AB实验</li>
</ul>
</li>
<li>效率优先
<ul>
<li>开发资源不足</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>搭建系统最简单实现</h1>
<p>基本元素：</p>
<ul>
<li>有限规则的输入端
<ul>
<li>可视化</li>
<li>API</li>
</ul>
</li>
<li>中间抽象数据
<ul>
<li>DB</li>
<li>json</li>
</ul>
</li>
<li>输出端
<ul>
<li>runtime</li>
<li>生成代码</li>
</ul>
</li>
</ul>
<blockquote>
<p>page = runtime(json)</p>
</blockquote>
<p>假设现在已经用这个公式解决问题了。</p>
<p>这个过程的本质就是一个DSL，所以DSL的局限性也包含了这里说的“搭建系统”的局限性，同时我们狭义的页面搭建系统也有局限性。</p>
<h1>2个项目简介</h1>
<p>用“搭建”的思路解决问题的过程中，主要做过2个搭建系统，他们除了都叫搭建之外，剩下的技术实现不同，用户不同，解决的问题也不同：</p>
<ul>
<li>电商营销会场H5页面搭建
<ul>
<li>平台用户：
<ul>
<li>万千电商运营</li>
</ul>
</li>
<li>技术架构：
<ul>
<li>react + jquery</li>
<li>java模版 + ssr</li>
<li>搭建组件 = React组件 + 组件的描述 + 定制编写的编辑区</li>
</ul>
</li>
<li>搭建能力：强
<ul>
<li>私有组件标准，组件之间可以嵌套，组合</li>
<li>线性布局，绝对定位布局，且能相互组合</li>
</ul>
</li>
<li>页面不需要可维护性</li>
</ul>
</li>
<li>花呗营销活动H5页面搭建
<ul>
<li>平台用户：
<ul>
<li>花呗运营</li>
<li>专业前端</li>
</ul>
</li>
<li>技术架构：
<ul>
<li>全栈中中台（react + eggjs + mysql）</li>
<li>CDN html + 异步接口</li>
<li>组件拓展性强</li>
<li>搭建模块等价于React组件</li>
</ul>
</li>
<li>搭建能力：弱
<ul>
<li>相当于 Array&lt;React.Component&gt; 的一维数组</li>
</ul>
</li>
<li>页面不需要可维护性</li>
</ul>
</li>
</ul>
<p>总结特点：</p>
<ul>
<li>核心目标是：效率
<ul>
<li>相同的模块标准，便于沉淀复用</li>
<li>充分灰度，快速上线</li>
</ul>
</li>
<li>NoCode
<ul>
<li>低门槛，少概念</li>
<li>非技术为主</li>
</ul>
</li>
<li>不在乎产物的可维护性和可拓展性</li>
</ul>
<p>可以看到这里做的2个搭建系统他们是相似又不相同：</p>
<ul>
<li>相似的：
<ul>
<li>营销，活动，</li>
<li>一次性，</li>
<li>低门槛</li>
<li>一套组件标准</li>
</ul>
</li>
<li>不同的：
<ul>
<li>使用者逻辑水平，</li>
<li>页面可交互复杂度</li>
<li>平台搭建能力</li>
</ul>
</li>
</ul>
<p>这么相似能不能在保留核心的特性下只加一点的改造就能互换一下在对方的业务里直接使用呢？不能。因为环境，需求的不同导致了平台之间有显著差异，所以不能。</p>
<p>那有没有可能一个搭建系统就能解决2个业务呢？那肯定能，因为站在现在的视角来看，需求已经确定成产品了，只要再统一一下抽象就行。</p>
<p>合并：提升抽象，提升复杂度</p>
<ul>
<li>搭建能力对齐，都支持多布局</li>
<li>组件标准升级，私有标准</li>
<li>按业务域划分租户，分隔平台用户</li>
</ul>
<h1>解决之后</h1>
<p>往广度思考：&lt;br /&gt;一个搭建系统只能解决一个垂直域的问题，如果要跨垂直域，那就意味着要把提升搭建系统的抽象程度，拆解一下把视图结构的用一种DSL，样式的部分用一种DSL，逻辑的部分再用一种DSL 。（黑人问号，重新发明一下html，css，JavaScript ？</p>
<p>往业务的深度思考：&lt;br /&gt;除了无法跨域，而且针对搭建系统的上游：需求，逻辑，无法充分收敛。因为上层是完全不可控的，即当技术侧发起的工具/服务无法解决满足上层需求时，就只剩下2个解法：</p>
<ul>
<li>人力填坑</li>
<li>需求变形</li>
</ul>
<p>这2个解法都会出问题</p>
<p>人力填坑相当于开了外挂，一旦开启则无法停下，搭建系统迅速失控名存实亡，沦为鸡肋，其存在的就变成了问题本身。</p>
<p>需求变形，即需求适应系统的短板，站在更上层的视角看，这是对业务的不可避免的伤害。</p>
<p>往技术的深度思考：&lt;br /&gt;如果一个搭建无法高效的解决全部问题，那就增多搭建系统的数量，创建能搭建搭建系统的高阶搭建系统，抽象搭建系统本身的组成：输入，中间数据，页面。那么，搭建系统的抽象如何拆解，</p>
<p>搭建系统A -&gt; 问题域X&lt;br /&gt;搭建系统B -&gt; 问题域Y</p>
<p>高阶搭建系统X -&gt; A, B -&gt; X, Y</p>
<p>如果：这时候来了新需求Z1，新需求Z1属于问题域Z。（比如：营销人传人）</p>
<p>如果A，B不能满足Z1，解决问题Z，那为什么X能解决问题Z ？可能性🈶2：</p>
<ul>
<li>X很先进，提前预判到了Z的存在
<ul>
<li>如何预判？怎么收集需求</li>
</ul>
</li>
<li>X很灵活，有拓展机制能够让开发者继续开发解决Z
<ul>
<li>本质是劳动力的转移（需要拓展多少？有没有可能是完全重写，那就X不就成了基础框架）</li>
<li>问题Z = 新需求Z(1-&gt; Infinity)  = ( 新搭建系统 =  高阶搭建系统 + 人力procode )
<ul>
<li>反问：如何衡量ROI，为什么不简化为“人力procode -&gt; 新需求Z0”，</li>
<li>反问2：再来个新的W问题如何？上游不可控</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1>如何突破</h1>
<p>看流程，视角也许可以从技术侧前移，看看能不能从需求侧解决，俗称：如果解决不了问题，可以尝试换个问题，看看在这整个过程，最核心的点是什么。不是最初的业务目标，而是基于目标描述的业务逻辑。</p>
<p>来自运营的需求目标： 1.提升MAU， 2.有一亿的预算，3.其它指标等&lt;br /&gt;产品分析之后并输出之后形成产品PRD：里面描述了产品逻辑，最后开发面对的是这一整套产品逻辑，包含用户，行为，状态事件，最后形成页面。</p>
<p>但是在搭建页面的这些逻辑被分散到各个组件里，经典的场景：在评审需求往往会有一个流程图，但在页面完成后这个流程图就没用了。</p>
<p>再深入一点，充分的把流程图用起来，让静态的流程图动起来。</p>
<p>建设以“逻辑编排”为核心的搭建体系，</p>
<h1>以“逻辑”为中心</h1>
<p>2个需求示例：日常花呗抽奖活动，花呗五周年小纸条</p>
<p>以流程图为中心，流程图里要包含的基本结构：</p>
<ul>
<li>生命周期上下文
<ul>
<li>内置变量，</li>
<li>内置常量，</li>
<li>基础自定义数据，如
<ul>
<li>
<pre><code>营销规则，人群规则
</code></pre>
</li>
<li>开始时间，结束</li>
</ul>
</li>
</ul>
</li>
<li>基本结构字段
<ul>
<li>人物等客观条件，Value Object
<ul>
<li>时间，</li>
<li>某个业务实体（物品，优惠券）</li>
</ul>
</li>
<li>计算节点
<ul>
<li>分支判断</li>
<li>用户行为事件响应（通常是点击，浏览</li>
</ul>
</li>
<li>渲染节点
<ul>
<li>渲染
<ul>
<li>渲染整个页面，页面是搭建来的</li>
<li>渲染局部，如弹框</li>
</ul>
</li>
<li>等待事件
<ul>
<li>等待渲染的UI 抛出事件（用户行为，自定义描述的事件）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>拓展信息：
<ul>
<li>逻辑覆盖率</li>
<li>监控</li>
<li>埋点</li>
<li>流量分布</li>
<li>自动化压测</li>
<li>自动化性能优化</li>
<li>业务转化率，漏斗，采集</li>
</ul>
</li>
</ul>
<h1>逻辑怎么不行了</h1>
<h2>示例1：抽奖</h2>
<h2>示例2：小纸条翻页</h2>
<p>1.是纯前端视角，格局没有打开</p>
<p>2.可覆盖的复杂度不够</p>
<p>“动态  &amp; 前后可翻动的小纸条”让我破了防</p>
<p>NoCode无法覆盖纯逻辑的部分，但是NoCode依然保留有能力无限且复杂的逻辑确定下来。</p>
<p>对业务来说可以是一个黑盒，黑盒只暴露接口，“动态  &amp; 无限可翻动的小纸条”有2个接口：翻页完成，翻页退出，借助Code的手段从而完成降维</p>
<p>和解，放弃完全的NoCode，重点解决其中的需求逻辑的确定性的部分</p>
<p>需求逻辑的确定性越高，需求逻辑的信息量就越大，编写程序就变得越简单，后续而二次消费也更容易，流程图变成填空题</p>
<p>3.无法很好的处理循环和循环退出&lt;br /&gt;拓展一下，即语义的逻辑和实际的程序逻辑不是一一一对应的，中间是有抽象的，如：</p>
<blockquote>
<p>点击tab offset=0 -&gt; getList
点击pagination offset+=1 -&gt; getList
程序：任意点击行为，offset changed -&gt; getList(offset)</p>
</blockquote>
<p>而且语义的逻辑经常会默认带一下脑内上下文，比如点击tab，默认就清空了前面的变量，或者意识人，非技术人员通常会分别 每个tab都是独立的逻辑，而程序逻辑则可能是为了性能，默认复用变量</p>
<h1>逻辑的边界</h1>
<p>当我意识到在逻辑上的产品经理（或需求方）不应该去关注如何底层的程序细节时，同时让产品描述逻辑是可行的，那就说明在这个产品 -&gt; 逻辑的路径上存在一个边界。</p>
<p>最先开始：产品 -&gt; 需求 -&gt; 工程师 -&gt; 逻辑</p>
<p>原本的设计：产品经理 -&gt; 逻辑（这里的逻辑即包含了业务逻辑和程序逻辑，同时工程师参与但也负责逻辑的正确性，完备性，逻辑有问题就如同需求有问题，如同程序出了bug）</p>
<p>业务逻辑一定包含程序逻辑，但反过来程序逻辑不一定是业务逻辑。（参照声明式编程和指令式）</p>
<blockquote>
<p>转账 = move(A.balance,B.balance)
借钱 = move(A.balance,B.balance)</p>
</blockquote>
<p>加入工程师之后的设计：产品经理 -&gt; 业务逻辑（声明式，关心用户，UI，业务状态） -&gt; 工程师 -&gt; 程序逻辑（类库或接口， 复用或者新开发，按业务逻辑进行填空，关心数据，稳定性）</p>
<p>当考虑到工程师角色参与之后，我意识到这个“边界”不是一个确定性静态的值，它应该是工程师和产品在认知上达成的统一共识，而且会随着产品不停迭代动态变化。“边界”的作用不再是对立性的，而是为了寻求最佳的解法。</p>
<p>再进一步抽象一下：</p>
<blockquote>
<p>产品 -&gt; 结构化后的需求 -&gt; 工程师 -&gt; 代码</p>
</blockquote>
<h1>结局</h1>
<p>一个瑕疵明显的NoCode方案，不容易打动人心，落地阻力大。</p>
<p><s>人们</s>工程师们对于NoCode和ProCode有很高的质疑，但对于lowCode则很包容</p>
<ul>
<li>no code表面太完美，工程师天然直觉认为必定非code不可解决的地方，这将来是一个深坑</li>
<li>pro code本就是工程师的专业领域，这是专业领域的碰撞，语言只有2种被人喷的和没人用的</li>
<li>low code 则取决于视角和比例
<ul>
<li>观点1：low的部分是帮助工程师减轻负担</li>
<li>观点2：code的部分是增加了工程师的负担</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t5" name="t5" >
  <article>
    <div class="markdown-body">
      <h1>前端的边界</h1>
<p>2022-04-11</p>
<blockquote>
<p>探索一下”前端“这个岗位在技术，职能的天花板</p>
</blockquote>
<h2>背景</h2>
<p>由“模型”中心衍生想到的，当我在尝试实践remix时，remix这种完全以form表单为中心，action处理的方式，跟很早之前的MVC（php，java servlet，其中的主要差别在于remix通过编译手段暴露很多中间状态，改善UI渲染，不能说很像，只能说是极其类似。</p>
<p>参考这个方式会突然想到，古典的MVC是很不适合做复杂前端应用的，所以remix也许这样，但为什么不适合</p>
<p>另外前端是从后端里产生的，但是为什么后端要把这个工作分离出来，仅仅是有人说的因为“后端不想干这个脏活累活”吗？</p>
<h2>还原一下</h2>
<p>如果不考虑其它因素，真的完全用php可以实现复杂前端应用吗？比如绘图工具，编辑器工具。明显地，应该是可以实现的，</p>
<p>比如把原本的js里的状态变量都设定为数据库表或者redis，每一次用户的行为都会触发form或ajax请求，在controller里处理状态并落库，之前刷新页面，重新读取数据库里的数据，最后渲染到页面</p>
<p>相比现在的前后端分离的模式，在技术唯一的差别：</p>
<ul>
<li>将原本的前端状态持久化到了数据库</li>
<li>确保前端UI是完全受控于数据库</li>
</ul>
<p>那么在这2个条件下，就能用后端实现一个完全复杂的编辑器应用，前端作为视图层需要完全的渲染HTML即可，如果使用form表单来提交数据，确实甚至都不需要js执行</p>
<h2>为什么不</h2>
<p>既然上述的方式存在确实可行，但现实是还是发生了拆分了，那到底是什么因素导致的呢？首先看下上面的弊端，统一在一起之后</p>
<ul>
<li>对人
<ul>
<li>素质要求变高，写的人必须同时写MVC</li>
<li>身兼多职，无法深入研究和解决单一领域问题</li>
<li>单点问题，一个人从头撸到尾容易成为瓶颈，工业化生产讲究分工协作，</li>
</ul>
</li>
<li>对事
<ul>
<li>数据冗余，很多用户的临时操作状态都必须存在数据库里，如果要节约资源就加上及时清理机制</li>
<li>体验不流畅，每步操作都必须走网络请求到服务端，链路长，响应时间久</li>
<li>计算资源浪费，状态的流转都必须借助服务端CPU，浪费了用户客户端的计算能力</li>
<li>耦合问题，全流程绑定到了一起，无法局部复用，无法提升后续效率</li>
</ul>
</li>
</ul>
<p>也许还有更多原因，但总结大体是2个因素导致了现状：</p>
<ul>
<li>（降本）节约（服务器）计算资源</li>
<li>（增效）生产效率</li>
</ul>
<p>降本：</p>
<ul>
<li>将临时状态，用户状态转移到前端内存或浏览器缓存，减少存储</li>
<li>状态的切换转移在js里计算，减少计算和网络请求</li>
<li>由于上述的操作，状态的存取都在用户内存里进行，响应加快，也间接的导致了体验变好</li>
</ul>
<p>增效</p>
<ul>
<li>分离产生的分工，专业的人做专业的事情，前后端分别负责V，C和M，在单点里提升专业度和效率</li>
<li>复用成为可能，由于分离后各自成为单独的抽象层，使得层的复用成为可能</li>
</ul>
<h2>边界的产生</h2>
<p>在分离后，并且随着互联网大发展，前后端在各自的领域里狂奔，在今天去区别一个前后端的人已经不是用“编程语言”来区分了，用js或java并不重要，重要前后职能的人在自己领域内的重点问题的探索，思考，实践，如：</p>
<ul>
<li>前端
<ul>
<li>生产力工具：低代码，web ide，富文本编辑器，各类平台</li>
<li>多端程序：DSL，跨多端多平台，小程序，BFF(SSR，serverless函数计算）</li>
<li>传统视图特色：Web GL，A/VR，游戏引擎</li>
</ul>
</li>
<li>后端：
<ul>
<li>计算性能：高并发，大数据，多媒体处理</li>
<li>存储：各种数据库，中间件，缓存，云盘</li>
<li>devops：容器虚拟，云原生</li>
<li>（列举不全，参考阿里云，腾讯云卖的各种产品）</li>
</ul>
</li>
</ul>
<p>以上只是一些举例，当然还有很多没列举到的。由于前后端在区分的边界上已经更注重于问题领域的差别，而不是手段或者工具，所以熟练的掌握一些工具的经验可以帮助我们更好的探索问题域，但不能本末倒置的沉迷在工具里，不需要再问“学react还是vue”这种问题了</p>
<h2>回顾一下更早的历史</h2>
<p>在最原始的时期，那时候连后端都没有，古典时期的程序员们就是直接面向数据库（计算机的本地的存储数据）开发，通过接收原始的输入存储，然后通过指令文本打印到命令行界面：</p>
<blockquote>
<p>命令行文本 &lt;--- 程序处理 &lt;--- 存储的数据</p>
</blockquote>
<p>在传统架构下，计算机仅需考虑用户本地的情况下，当互联网产生的时候，C/S架构也产生了，命令行界面的数据不一定来自于本地，也有可能来自于其它ip的计算机，其它ip的作为数据和计算服务提供者，才称作服务器。逐步逐步演进到今天后，随着问题的解决，以及新的问题越来越大越复杂。</p>
<p>为了适应这种变化，职能的分工也就陆续产生了，虽然职能诞生了，但会发现整个程序的基本模式并没有大变化，变化的是每个流程里不断的细化分工，不断提升的是整个系统的计算能力，输出（传输）能力，存储能力</p>
<blockquote>
<p>输出（多端） &lt;--- 中间处理（服务器架构或客户端）&lt;--- 底层数据（集群）</p>
</blockquote>
<h2>面向更极致的未来</h2>
<p>由于基础设施的完善，生产力工具的爆炸，以及人员素质的提升，也许使得一个人已经可以负担足够多的复杂度。想想看，现在写一个登陆系统，博客系统比之前的时代有了多了多的提升。</p>
<p>继续迭代生产力工具，提升抽象，降低对用户的复杂度，使得之前的复杂应用降维成了现在的简单应用。</p>
<p>所以在今天的场景里，也许已经有办法让一个人或一个职能去负担一个完整且复杂的应用，如果有一个种新的工具具备描述一个完整的功能，通过功能的叠加和组合，再去诞生出一个应用。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t4" name="t4" >
  <article>
    <div class="markdown-body">
      <h1>以“模型”为中心</h1>
<p>2022-04-08</p>
<blockquote>
<p>不想再写一次登录系统了</p>
</blockquote>
<h2>Nextjs</h2>
<p>深度使用nextjs后的感悟，发现nextjs这种以serverless为中心的设计复用的，以路由即页面</p>
<p>这样的问题是由于serverless缺少模型的信息，导致在业务逻辑就只能在前端UI的逻辑里面处理，同时在设计时，需要区分前端的状态和模型的字段</p>
<p>这导致的一个问题，设计书写一个完整功能是被分割成了3个地方：ER模型，serverless或前端处理逻辑，UI</p>
<p>在架构上就处于3横多纵的模式，这样的好处是相同层容易互相复用逻辑（耦合），局部的横向造成了耦合，但却无法整体导出</p>
<p>如果以模型为中心，只构建纵向，横向的建联通过直接的引用。</p>
<pre><code class="language-typescript">// module2.jsx
import { useApi: useApi1, Component } from 'module1.jsx'

export function useApi () {
  const use1 = useApi1()
  return {
    findFoo () {    
      use1.findAndDoSomething('')
    }
  }
}

export function Component () {
  return (
    &lt;newDialog&gt;
      &lt;Component /&gt;
    &lt;/newDialog&gt;
  )
}
</code></pre>
<p>这样的模型，severless，UI为组合，那就像之前的MVC架构， M -&gt; C -&gt; V -&gt; C -&gt; M的流程</p>
<p>这里有个问题，当M -&gt; C -&gt; V之后，其实在V层面已经收到了来自于C层经过计算之后得到的状态，为什么当状态修改的时候，还需要显示的调用 V -&gt; C -&gt; M 把数据再还原回去呢，为什么不能逆向计算后，直接 V -&gt; M？</p>
<ul>
<li>不是所有的计算都是可逆的，那哪些计算可逆？</li>
<li>也不是所有的V都需要直接到M，有些是临时状态需要缓存，如何显示的区分这些状态</li>
</ul>
<h3>发散</h3>
<p>http server 是无状态的或者只缓存状态，模型里只保存最原始的数据或者为了性能考虑保存需要大量计算的数据或索引</p>
<ul>
<li>怎么判断哪些状态字段需要持久到模型中？
<ul>
<li>如状态不存在模型中，那么模型到状态之间总是需要一个计算，好像是serverless不可缺少？</li>
</ul>
</li>
<li>“状态”如何在 server/website 中同步 ？</li>
</ul>
<h2>前后一体化单元</h2>
<p>实现一个功能最小单位至少包含：UI，serverless或useHook，Model ，（其中UI和model至少有1个）</p>
<blockquote>
<p>另外的场景：单独的后端很少会讲到复用，但当说到复用的时候，系统负责的领域足够大时，这就成了“中台”</p>
</blockquote>
<ul>
<li>没有Model
<ul>
<li>静态站点，博客</li>
<li>Sketch，PS工具（广义来说，ps文件作为输入，也应视作Model）</li>
</ul>
</li>
<li>没有UI
<ul>
<li>API gateway（这种是中间件，这个好像Model也没有，但这个不够广泛</li>
<li>CDN服务，Open API服务，各种后端服务系统</li>
</ul>
</li>
</ul>
<p>在不考虑“用户”的情况：Model最重要，数据是资产&lt;br /&gt;在考虑“用户”的情况下：UI最重要，能用和好用</p>
<p>一体化单元之间的互相组合有2种形式：</p>
<ul>
<li>静态，需要版本管理
<ul>
<li>就像类库的引入，之后2个单元就是相同的工程，
<ul>
<li>问题：model层是一个大集合，同时无法拆分，存储成本</li>
</ul>
</li>
</ul>
</li>
<li>动态，需要运行时
<ul>
<li>就像微服务或中台，引入的其实是SDK，2个单元不能算是一个有机的整体，只是允许互相调用的服务
<ul>
<li>问题：model层会成为单点</li>
</ul>
</li>
<li>一旦动态之后就需要：服务的发现，注册，订阅，销毁等生命周期，</li>
</ul>
</li>
</ul>
<p>一体化单元要暴露的是：</p>
<ul>
<li>Serverless或hook</li>
<li>UI</li>
</ul>
<p>微服务</p>
<ul>
<li>持久层隔离
<ul>
<li>底层Model之间的关系的引用和处理，跨数据库，这个怎么索引和建联？</li>
</ul>
</li>
<li>公用Model
<ul>
<li>单点问题</li>
<li>大表索引问题</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t3" name="t3" >
  <article>
    <div class="markdown-body">
      <h1>快速理解next.js</h1>
<p>2022-03-17</p>
<p>最近尝鲜真正投入在业务场景里使用了下nextjs，但在刚开始用不久，就产生了一个疑问：</p>
<blockquote>
<p>想在next.js 初始启动的时候去连接数据库，应该怎么做呢？</p>
</blockquote>
<p>在参考了官方示例之后（<span class="inner-link"href="https://github.com/vercel/next.js/tree/canary/examples/with-mongodb">https://github.com/vercel/next.js/tree/canary/examples/with-mongodb</span>）</p>
<p>我有点悟了，发现完全误解了nextjs的真正形态，简单来说：nextjs不是一个带了node服务的前端框架，而是一个集成加强型view的node server</p>
<p>上述的疑问背后的真正问题是：我不了解nextjs，我在尝试寻找nextjs的server的“入口”，而实际上nextjs整个就是server</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t2" name="t2" >
  <article>
    <div class="markdown-body">
      <h1>探寻Low Code</h1>
<p>2022-01-16</p>
<h2>概览</h2>
<p>low code（包含no code）一种通过提高抽象，隐藏程序细节的方式而设计出来的面向具体业务（领域）的平台工具，其目标一般是提效（原本角色做的更快更不容易出错）或者赋能（能做他们本做不到的事情）</p>
<p>在公司平台里有大大小小不同的low code平台，针对不同的业务域问题，设计了不同的组件，服务系统，接口，可视化界面等等，然后在自己的业务域里不断迭代着</p>
<p>但是这些low code系统在往往只根据具体问题，设计了具体功能，现有的技术进行代码堆砌，最终出来一个“平台” ，但背后的底层抽象却鲜少提及。</p>
<h2>回溯历史</h2>
<p>我们现在每天接触的JavaScript，java等，通通都是称为高级语言，在高级语言之下的是低级语言，如汇编，机器语言。现在已经不再写汇编了，我们已经可以通过更高抽象的高级语言来完成工作，因为这样更加高效也更准确。所以高级语言某种意义上也是一种low code。</p>
<p>但光有在JavaScript还不够，还不够快，通过语言的特性，上面诞生了各种各样的UI框架，vue，react。这些框架也通过更加高级的抽象，改变了前端工程师的开发方式。这也是一种low code。</p>
<p>在UI框架之上，还有更上层的抽象，如remix，next.js等，通过引入服务端的能力，让前端工程师的技术的纵深又深了一步而且学习的成本很低。</p>
<p>可以看到随着时代的发展，在编程界的工具都是不断提升的抽象，而且领域越来越细分
<img src="./2_1.png" alt="抽象层次"></p>
<h2>一个有意思的问题</h2>
<p>问题：搭建系统的搭建系统（高阶搭建系统）是否有存在的意义？</p>
<p>辅助说明：只通过提供 library 的方式不能算高阶搭建系统
抽象程度：高阶搭建系统 &gt;  搭建系统，
问题域范围：高阶搭建系统 &gt; 单个搭建系统，但 高阶搭建系统 &gt;=  子搭建系统的并集</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t1" name="t1" >
  <article>
    <div class="markdown-body">
      <h1>图形开发</h1>
<p>2020-08-10</p>
<p>前端本质是一个图形开发的子类，而图形开发最终，最高级的形态应该就是游戏，3A游戏。</p>
<p>一个成功的游戏应该是要涵盖图形技术，编剧，音乐，美术，交互互动，是各大类型技术的集大成者。图形开发虽然只是其中的一个分支，但它是其它分支表达的出口，就像小数点前面的1。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t0" name="t0" >
  <article>
    <div class="markdown-body">
      <h1>流程化系统设计</h1>
<p>2019-09-15</p>
<h2>描述</h2>
<p>流程化的执行，是一个中心化的调度者。通过流程 + 服务调用的能力，可以把各种各样的服务进行串联的系统。</p>
<h2>节点树 + 执行器</h2>
<p>中心系统的前端UI界面经过用户的意志产生了节点树（Node Tree），上传到系统中，执行器（Runtime）去执行对应的节点树（Node Tree），就像手写js代码，然后放到服务器node环境中执行一样。</p>
<h2>标准服务模块</h2>
<p>中心系统本身基本没有服务的能力，只能执行流程，调用服务。所以外围注册的服务模块的决定了流程系统的上限。就像nodejs调后端接口一样</p>
<p>整个体验的过程就像是可视化编程一样，程序 = 逻辑 + 服务 + 执行</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
  </main>
</body>
<script src="./content-script.js" ></script>
</html>