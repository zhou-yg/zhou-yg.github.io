<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>What!</title>
  <link type="text/css" rel="stylesheet" href="./content.css" />
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-P65RJH2DCW"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-P65RJH2DCW');
  </script>
</head>
<body>
  <header>

  <img src="./logo.jpg" alt="logo" />

  <!-- <span class="slogan">我不知道你在说什么</span> -->

  <div class="navs">
    
      <a href="./index.html" >首页</a>
    
      <a href="./about.html" >关于</a>
      
  </div>

</header>

  <main>

<<<<<<< HEAD
    <a class="a-link" href="#t18" name="t18" >
  <article>
    <div class="markdown-body">
      <h1>为什么无法用代码行数衡量产出</h1>
<p>2022-07-16</p>
<h2>问题？</h2>
<p>众所周知，程序员的工作产出除了完成各种需求之外，就很难再有一个简单，客观的标准评判他的工作产出，从而实现像销售提成般那样的按劳分配的绩效制度</p>
<p>在一般的公司，有些管理者想作妖的时候，往往就会想统计每个程序员的代码量，从而基于代码量来给每个程序员打绩效，但这显然是可笑的，《神秘的程序员们》也有一期专门讽刺这个的漫画</p>
<p><span class="inner-link" href="https://cdn.nlark.com/yuque/0/2022/png/329030/1657978715892-fba36e6b-4428-4c15-80cc-142d420046c0.png#clientId=u90b7d930-ae57-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;height=368&amp;id=ue820497d&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=2839&amp;originWidth=702&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=963192&amp;status=done&amp;style=none&amp;taskId=u32c000dd-e70b-4c85-a776-3fe037cfc8b&amp;title=&amp;width=91">漫画示例</span></p>
<p>这里问题潜藏的是另一个问题，为什么我们的总是推崇更加抽象的代码，更加通用的架构设计 ？直接说我的想法，那就是抽象的代码的生产力比具象代码更高，因为抽象代码的“可能性”更高，能解决更多的现实问题</p>
<p>可以尝试用数学函数的角度来推理一下</p>
<h2>数学函数</h2>
<p>数学里的函数是由连续的点组成，所以抽象程度高低的就是数学函数所包含的点数</p>
<p>y = { 0,  1 }  就只能代表2个点，而 y = x，就是可以包含这条斜线上的无数个点，明显后者的抽象程度更高</p>
<p>反推到我们的日常的代码， 最简单的例子：</p>
<pre><code class="language-javascript">// 方法1
function foo (prop) {
  return {
    name: 'fooObj',
    value: prop === 'foo'
  }
}
// 方法2
function foo2 (props) {
  return {
    name: 'fooObj',
    ...props,
  }
}
</code></pre>
<p>很明显方法2的抽象程度更高，因为方法2可以适配更多的情况，而方法1就相对固化。因为通过简单的有限的几组传参我们就能知道，</p>
<ul>
<li>方法1：只能有1个参数，2个返回结果，</li>
<li>方法2：可以有无数个返回结果，并且这些无数结果里包含了方法1的，</li>
</ul>
<p>从这个论证里就能得知我们衡量抽象的其中一个标准就是：一组代码在运行时能够映射出的静态代码的数量，数量越多，就约抽象</p>
<pre><code class="language-javascript">function add1 (a) {
  return a + 1
}

function add2 (a, b = 1) {
  return a + b
}
</code></pre>
<p>如果能把上面的函数，用number数字填充并展开，生成静态，add2多出add1，至少多出 （b - 1）行，所以add2 抽象程度更高</p>
<p>当然实际的开发过程中的代码比上面的示例复杂了非常多，还有各种语言特性，设计模式等，一个抽象函数能够映射出的静态代码几乎是不可衡量，只能各种最佳实践的参考，理论的推理，以及凭借程序员技术的感觉来判断，这是一个极其复杂的过程</p>
<p>所以除非这么一个AI，它可以识别出每个抽象函数的映射，甚至可以再简单一点，它能对比任意2个函数的抽象程度的大小，这时候就也许就能实现用代码给程序员打绩效了。但是用屁股想都能知道，这个能“理解”抽象的AI得有多厉害，拿来做这个事情，实在太小儿科了。</p>
<p>但是谁能说的准呢，毕竟几十年前的计算机科学家们也想不到在机器性能成千上万倍的爆炸之后最主要的用途之一是用来看美女跳舞</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t17" name="t17" >
=======
    <a class="a-link" href="#t17" name="t17" >
>>>>>>> 21df66265e5af36ac5f227d5bfe893c88f485263
  <article>
    <div class="markdown-body">
      <h1>再谈学习</h1>
<p>2022-06-25</p>
<p>上周跟人聊天说了关于程序员为什么终身学习的事情，发现有很多地方值得总结</p>
<p>为什么现在的程序员都陷入了一种学习焦虑，一听到有“新框架”，“语言”就直呼“真学不动了”，但过了一段时间天就抱着资料开始啃了</p>
<p>原因我想主要是2个方面</p>
<p>1.知识更新迭代快</p>
<p>尤其是应用层相关的，那真是层出不穷，琳琅满目</p>
<p>应用型的知识更新迭代快，而且这个新知识往往是开源的，因为IT技术无国界，这是全世界的技术人一起推动的，没有任何准入门槛，更重要的最新的知识大概率比旧知识要好。</p>
<p>这里另外举例在另一个也需要终身学习的行业里，虽然他们的知识更新也许没那么快，比如医生或律师，他们往往是因为现有的知识都有用，而且实在是太庞大了，终身都学不完。</p>
<p>2.钱热人多</p>
<p>尤其是年轻人多，</p>
<p>一个10年的程序员并不一定比5年程序员的技术水平先进5年</p>
<p>因为年轻人的成长速度可以很快的，因为他们不需要学习“错误”的知识，不走弯路，花最少的时间，可以直接追赶最新，最正确的技术。</p>
<p>外加“知识更新快”会给已入行的中年人施加影响，让他们过去的经验遭遇了贬值，所以中年人也必须立刻跟进，不然就会被掌握了新知识的年轻人淘汰。</p>
<p>但是年轻人也要注意，一旦到达了最新知识的前沿，他们也就慢下来，接下来就进入了跟同样达到最新知识前沿的中年人进入同一个“时空”，然后一起等待下一轮的“新知识”。下一轮新知识来临的时候又会淘汰一批赶不上的中年人和年轻人</p>
<h2>启发</h2>
<p>所以对于日常要学习的知识的选择就很重要了，这些知识通常有一个很明显的特征：1.不容易过时，也没有学习捷径 2.围绕客观的“人性”</p>
<p>这类知识通常才是真正能拉开差距的知识，一旦学会就构建了对他人的错位优势</p>
<p>除了此外，还有相关学习的指导方法，我列举了在技术领域会做的事情</p>
<p>1.底层，原理性知识</p>
<p>尤其是很多知识看似是新增的，其实在技术思想或核心原理都是换汤不换药</p>
<p>但这些底层的知识的选择就关键，因为时间是有限的，比如我作为一个前端就不太能花大量时间投入对操作系统的研究，不如好好研究透chromium</p>
<p>学习知识的时候应该更多的关注于本技术领域的，不要限定职责</p>
<p>我会多学习类似关于：编程范式，设计模式，语言的设计实现等诸如 跟领域有关，但不限定于前端开发的基础知识。</p>
<p>另外对于热门技术除了使用之外，也要了解最原子的实现原理，比如docker，这个挺好用，我不知道他是怎么实现，但能了解它最底层是linux提供的各种隔离API层层叠加后实现的伪虚拟，这种隔离达到虚拟效果的思想，也间接启发了现在的微前端框架的设计实现</p>
<p>还有一些软件工程本身的经典著作理论就不一一列举了</p>
<p>2.跨领域的高性价比知识</p>
<p>不同于本领域你可能都学，但其他学科，可以只挑选最精选的知识。这些知识可以很好的指导我们完成领域职责的工作</p>
<p>比如基本设计原则，这可以培养前端在看UI不只是凭感觉，还能看排版，也可以协助日常的PPT制作，这些只需要花很少的时间就能学会</p>
<p>3.客观的人性</p>
<p>就像很多说的35岁要转管理一样，其中的管理学作为一种围绕组织和人性的知识技能，掌握了就能终身使用。</p>
<p>当然这些也不是万能的，说不会被淘汰只是以我的认知水平，结合业界做的一个有限判断</p>
<p>说不准哪一天又有新的技术升级，会带来全新的体系，到时候又是洗牌的一天。所以说还是GWY好，以不变应万变（狗头</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t16" name="t16" >
  <article>
    <div class="markdown-body">
      <h1>技术为谁服务</h1>
<p>2022-06-25</p>
<p>“技术是为业务服务的”，相信很多做前端的人都非常笃定这句话。</p>
<p>现在很多的技术言论基本都是服务端发出来的，他们从业人员多，占比大，话语权大，容易并获得广大程序员圈里的人的认可。有没有可能有些言论观点并适用于以“大前端”为主的技术，就比如这句的“技术是为业务服务的，没有业务价值的技术毫无价值”，我想了下这个其实并不适用于“前端”这种以用户为主的技术体系，换成前端领域，应该改成“技术是为用户服务”（这个用户可以是客户，也可以是其他技术人）</p>
<p>这里很多要做反驳说，做好用户服务，体验好，评价高，最终也是还会提升业务价值。这想起了在内网看到的，有举例说淘宝，咸鱼全面APP化，逼迫用户从PC转到手机的场景是不是符合客户第一的解释说明，高层反馈说：虽然强奸用户转手机看起来是为了业务，但长远来看，用户到手机之后发现购物更好更方便，其实是也是客户第一，符合客（ye）户（wu）的长期价值。</p>
<p>很明显，这里将用户跟业务不是等号，因为在国内环境用户未必是真的第一，业务实际才是第一。举个例子：就像银行窗口和银行系统，窗口和柜员是直面服务储户的，柜员和窗口只是储户和银行系统的传话筒，银行系统才是银行的业务，里面有各种跟钱有关的规则，管理者，对于这个业务系统来说，作为用户的人不是Entity，只是是具有Money的Value Object。对于业务系统来说，对于用户就只有一句，那就是“亲爱的用户，我是你die”</p>
<p>但对于前端而言，我们的用户是一群形形色色的人，不只是value Object，有手或有脚或有眼，有喜怒哀乐，前端技术应该为他们服务，提供便捷，流畅，无障碍，协助他们在业务系统要做的事情，满足需求，提供快乐。做好用户服务，体验好，评价高，最终也许会提升业务价值，也可能不会。</p>
<p>比如APP的各种弹框，红点，点击离开页面还给你挽留一下。经常是一段时间框不弹，业务数据就明显的往下掉了。在这种大环境下，业务第一，客户第N，互联网高层现在早就远离一线，也许在早年可能会直面客户，做做冷启动，但现在只能沉浸了业务里的没的感情的数字里，每天碎碎念“低频/高频，高活/低活，GMV/营收/流水”，恨不得一个弹框贴你脸上直接就完成KPI。这想起了在内网看到的，有举例说淘宝，咸鱼全面APP化，逼迫用户从PC转到手机的场景是不是符合客户第一的解释说明，高层反馈说：虽然强奸用户转手机看起来是为了KPI，但长远来看，用户到手机之后发现购物更好更方便，其实也算是客户第一，符合客（ye）户（wu）的长期价值。</p>
<p>而那些本应注重于用户的“前端”的人，却信“业务第一”，再也不主动关心用户，转而去躬身入局深入业务，培养所谓的业务sense，最后跟服务端们一起坚持“业务第一”，做起来高并发/可用之类的“流量生意”。等做需求就发现，惊觉头顶的title其实是“前端”，该糊的页面一个不少，加上在业务系统里舔到的一些脏类活，最后匆忙糊完需求，补2句“用户体验”，“业务目标”之类的，提醒别人，也可能是自己，前端不是只会糊页面，还很注重用户体验和业务。虽然这没人在乎，但迫于互联网圈内的“政治正确”，大家纷纷亮起来大拇指，称赞2句，不愧有业务sense才能做出这么好的体验</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t15" name="t15" >
  <article>
    <div class="markdown-body">
      <h1>web工程师的门槛</h1>
<p>2022-05-25</p>
<p>基于在web领域的多年探索的经验总结，我认为的是在于3点：</p>
<ul>
<li>能将具象事物进行抽象总结的抽象能力</li>
<li>基于已知实事，对未知问题进行推理的逻辑能力</li>
<li>对于已有的技术工具，生产力工具的使用经验</li>
</ul>
<p>而且在编程生涯里，这2种能力会伴随着编程的深入，经验的积累，认知的提升，这两种能力会逐渐加深，最后呈现出的效果是：</p>
<blockquote>
<p>一眼看透事物本质的人和用了半辈子才看透事物本质的人是不一样的</p>
</blockquote>
<p>工程师们非常熟悉的工具，技巧，对于非工程师来说也有时间成本上的门槛，但这部分门槛并不高，而且会随着新工具的出现逐步降低，新的工具总是越来越简单，越来越强大</p>
<blockquote>
<p>如果有工程师发现在现有工作中积累的是工具经验，而不是能力，那其实是很“危险”的</p>
</blockquote>
<p>出于上述观点，如果有低（无）代码系统是号称给无编程技能和经验的人使用，但系统却无情的充满抽象和逻辑，全新的学习成本，那就陷入了一种悖论：</p>
<blockquote>
<p>卡拉赞没毕业打什么卡拉赞</p>
</blockquote>
<p>但随着技术的普及，普通人的思维其实也在持续的“提升”，像快手，抖音的风靡普及了“算法”，“AI”的概念，提升了大众的认知</p>
<p>在触及过web领域内的非工程师们，每天不可避免的会接触很多的技术，概念，数据，他们是比领域外的人有容易的机会，更低的成本能够去完成程序的内容。</p>
<p>那有没有编程范式和相应的工具，可以稍微降低上述的门槛，能将非工程师们一点点的带入到程序的世界？</p>
<p>这时有机会去完成这件事的，新的编程范式，工具应该只使用易于理解的数据结构和计算过程：</p>
<ul>
<li>数据结构：图/树/列表</li>
<li>计算过程：函数式编程，算法模型</li>
<li>工具：“常见&amp;成熟”的可视化编辑器</li>
</ul>
<p>参考：<span class="inner-link" href="https://gmtc.infoq.cn/2021/shenzhen/presentation/4069">https://gmtc.infoq.cn/2021/shenzhen/presentation/4069</span></p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t14" name="t14" >
  <article>
    <div class="markdown-body">
      <h1>React Hooks的实现细节</h1>
<p>2022-05-19</p>
<h2>概览</h2>
<p>出于设计useServerless的需要，最好能参考React源码的实现</p>
<p>react Hooks的实现作为前端经典八股文之一，之前已经大致了解内部是基于循环链表的实现过程，但仔细回想后，发现虽然了解了它的原理（WHAT）还是有很多地方不明白为什么要这么写（WHY），比如</p>
<ul>
<li>为什么hook数据对象使用的是链表？数组可以吗？</li>
<li>hook的queue跟hook数据的链表不一样，反而是环状链表？</li>
<li>为什么Dispatcher要分成 HooksDispatcherOnMount 和  HooksDispatcherOnUpdate 2类？</li>
<li>useState的计算的时机为什么是下次更新的时候才Merge ？</li>
</ul>
<p>以useReducer为例，hooks的源码出处：
<span class="inner-link" href="https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js">ReactFiberHooks.new.js</span></p>
<h2>基本原理说明</h2>
<p>在Hooks实现里最重要的事情，就是useState和useEffect之类的hook函数，能够知道当前执行的上下文信息，包含：</p>
<ul>
<li>当前是哪个Component在调用这个hook函数</li>
<li>现在这个hook函数，它调用的入参 和 上次存储的值是多少？</li>
</ul>
<h3>1.如何hook被哪个Component调用了？</h3>
<p>受限于JS的语言特性，strict模式下的当前函数无法获取当前的caller是谁，参考：<span class="inner-link" href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Functions/arguments/callee">callee</span></p>
<p>所以一般情况下需要通过一点技巧来实现，即通过劫持函数执行前后的全局变量，维持一个调用栈</p>
<p>这样在render函数在执行的时候，当前全局变量里最新的Component就是当前正在执行的Component</p>
<p>为什么可以这么做？是因为JS是单线程执行模型，代码在执行是同步的在一个线程里共享内存变量，所以才能用这个“技巧”</p>
<blockquote>
<p>拓展思考：如果是多线程里，如何实现这个功能呢？</p>
</blockquote>
<pre><code class="language-javascript">let globalCurrent = []
function run() {
  pushGlobalCurrentStack(ReactComponent)
  ReactComponent.render()
  popGlobalCurrentStack()
}
</code></pre>
<h3>2.获取上次的存储值</h3>
<p>总所周知，React的hook的值是存储在Component对应的Fiber中，所以只有能找到Component就能找到Fiber</p>
<p>在hooks有2个数据的来源，hooks初始设定的参数作为默认值，上一次的提交的action和上一次的值</p>
<ul>
<li>mount时
<ul>
<li>关心初始参数，保存到 hook的memoizedState 和 baseState</li>
</ul>
</li>
<li>update
<ul>
<li>关心上次dispatch的action变更，和 hook的memoizedState，计算出新的值并保存</li>
</ul>
</li>
</ul>
<p>由于mount和update的完全不同，所以需要区别2者，React的判断方法是：通过Fiber</p>
<pre><code class="language-javascript">// renderWithHooks current:Fiber
ReactCurrentDispatcher.current =
  current === null || current.memoizedState === null
    ? HooksDispatcherOnMount
    : HooksDispatcherOnUpdate;
</code></pre>
<h2>useReducer的数据结构</h2>
<p>分成2步：</p>
<ol>
<li>获取当前的hook对应的数据对象，通过 mountWorkInProgressHook</li>
<li>构建hook的返回 pair 结构 [state, setState]</li>
</ol>
<p>为什么useReducer每次都需要从Fiber中取数据，不能直接跟自己关联，2个原因：</p>
<ol>
<li>useReducer本身是全局引用，不能被污染。
<ol>
<li>除非在useReducer在Component进行实例化，在实例化的useReducer上挂数据，但受限于React的 Function Component的特性，这行不通。因为每次渲染的时候，Component作为一个Function会重新执行一次，执行的时候，函数body是从0开始执行的，useReducer每次都会被重新实例化</li>
</ol>
</li>
<li>受限于语言特性，函数无法在function body内保存数据，useReducer只能将自己依赖的数据，保存到一个hook对象，并挂在当前Fiber里，用到的时候再取出。</li>
</ol>
<p>如果真不想的每次都从外部的Fiber中取数据，将数据内存在组件内部，就必须得做到2个方面：</p>
<ul>
<li>Component 初始化只执行一次，重新渲染的时候，函数不再重新执行那么就不会重新实例化</li>
<li>Component 的render逻辑需要在第一次执行的时候就跟状态数据绑定“关系”，这样就即修改数据不用初始化，仅render 视图就可以了</li>
</ul>
<blockquote>
<p>嗯没错，这就是Vue.setup的核心思想了，条条大路通罗马</p>
</blockquote>
<h3>1.获取当前hook数据对象</h3>
<p>mount的逻辑相对简单，只需要做2件事情</p>
<ol>
<li>初始化最基本的数据结构接口</li>
<li>将当前hooh对象 append 或 init 到全局</li>
</ol>
<p>hook对象的构建链表的过程：</p>
<ol>
<li>第一个 hook1
<ol>
<li>currentlyRenderingFiber.memoizedState = workInProgressHook（全局，此时为null） = hook1
<ol>
<li>currentlyRenderingFiber.memoizedState = hook1（这个Fiber下的hook起点始终指向hook1，这样才能通过遍历链表找到所有的hook数据对象</li>
</ol>
</li>
</ol>
</li>
<li>第二个 hook2
<ol>
<li>workInProgressHook = hook2， hook1.next = hook2</li>
</ol>
</li>
<li>后面重复这个过程</li>
</ol>
<p>经过mount的初始化之后，此时我们就得到了一条hook数据构建的单链表：</p>
<blockquote>
<p>currentlyRenderingFiber.memoizedState（hook1)  -&gt; hook2 -&gt; hook3 ...</p>
</blockquote>
<p>update的逻辑会稍微复杂一点，并且已经它的逻辑是已经经过mount了，认为已经有一条hook的单链表的前提下</p>
<p>在update里有2种hook对象，分别是：</p>
<ul>
<li>nextCurrentHook
<ul>
<li>初始化时来自于 currentlyRenderingFiber.alternate.memoizedState</li>
<li>此时正在更新中，currentlyRenderingFiber是当前workInProcess，是新Fiber，它的alternate指向的是旧FIber</li>
</ul>
</li>
<li>nextWorkInProgressHook
<ul>
<li>表示当前正在执行的hook数据对象，即新Fiber的hook数据对象
<ul>
<li>如果第一个hook（nextWorkInProgressHook == null时）则来自于  currentlyRenderingFiber.memoizedState，指向的是新Fiber的链表的头部</li>
<li>否则来自于 workInProgressHook.next （即上一个hook数据对象的next)
<ul>
<li>新FIber的hook链表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对alternate的补充说明：update的逻辑点正是在于 alternate的差别，了解React源码会知道React在更新的时候会有一个“2棵树”逻辑，基于待更新的Fiber，构建一个新的Fiber链表，新的iew会使用新的Fiber链渲染，并替换旧FIber，它们之间通过alernate关联，所以 fiber.alternate 可以理解为最新的fiber节点</p>
<blockquote>
<p>oldFiber.alternate === newFiber
newFiber.alternate === OldFiber</p>
</blockquote>
<p>在useReducer的update逻辑，在第一个hook执行会有一个迷惑点，即</p>
<ul>
<li>nextCurrentHook来自于旧Fiber， currentlyRenderingFiber.alternate.memoizedState</li>
<li>nextWorkInProgressHook来自于新Fiber</li>
</ul>
<p>React在这里主要是行为将旧Fiber的hook数据对象，复制到新Fiber的hook数据对象中，下面展示的是clone hook的过</p>
<p>update的取数据对象的过程中：</p>
<ol>
<li>第一个 hook1
<ol>
<li>分别取出新旧Fiber的hook链表的第1个
<ol>
<li>old-hook1： 此时currentHook不存在，所以得从旧Fiber中先取出第1个 currentlyRenderingFiber.alternate.memoizedState，并设置到全局作为currentHook</li>
<li>new-hook1：nextWorkInProgressHook也不存在，从新Fiber的currentlyRenderingFiber.memoizedState取出作为第1个</li>
</ol>
</li>
<li>将旧Fiber的hook链表头clone到新Fiber
<ol>
<li>currentlyRenderingFiber.memoizedState = 从旧Fiber上克隆的 old-hook1</li>
<li>此时 workInProgressHook 就是执行新Fiber的hook链的头部，即new-hook1，同时把new-hook设置到全局workInProgressHook，作为下一个turn的启动点</li>
</ol>
</li>
</ol>
</li>
<li>第二个 hook2
<ol>
<li>还是分别取出新旧Fiber的hook链表的第2个hook数据对象
<ol>
<li>由于此时全局的currentHook已经存在（指向的是old-hook1），直接使用currentHook.next</li>
<li>workInProgressHook已经存在（指向的是new-hook2），直接使用workInProgressHook.next</li>
</ol>
</li>
<li>同上的克隆过程</li>
</ol>
</li>
<li>后面重复这个过程</li>
</ol>
<p>经过取hook对象的过程，也完成了旧Fiber到新Fiber的数据克隆过程，update的逻辑之所以复杂，是因为同时涉及取数据和克隆hook的过程</p>
<p>这么设计的原因，基于函数式的特点，所有的计算都是lazy的，React在内部的大部分编程代码里都遵循了这一个原则</p>
<h3>2.执行并计算hook</h3>
<p>计算hook也是一个lazy的过程，当setState的时候，对应React，这个只是触发更新的一个信号，此时并不会将setState的入参更新到Fiber.memoizedState里，</p>
<p>计算hook的有1个特点：会进行优先级判断，并且在判断后会进行会将剩余的低优先级action保存到hook中，等待下次的渲染，同时要保存的时候要维持之前action queue的顺序，</p>
<p>而queue用到的数据结构化是环状链表，queue.pending始终指向最后一个插入的update，即链表的尾部</p>
<blockquote>
<p>queue.pending = upadete3 &lt;-- update2 &lt;-- update1 （ = update3.next）</p>
</blockquote>
<p>用了“环”之后，它的巧妙之处在于就可以</p>
<ul>
<li>当有新的update插入时，可以直接插入到链表的末尾</li>
<li>当在useReducer需要进行更新的时候，要按顺序进行遍历的时候，只要访问 queue.pending.next（因为是环状的，所以尾部的next就是头部）就可以立刻从头部开始</li>
</ul>
<p>这种实现在JS里在，用数组当然也能实现，主要还是因为JS的数组非常“强大”。但使用“环状链表”确实非常的酷炫，另外一个可能的好处是queue.pending保存最后一个updaet就行，</p>
<p>遍历完update的之后后面就是简单的 newState = reducer(state, action)这一套，同样是遵循lazy的设计。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t13" name="t13" >
  <article>
    <div class="markdown-body">
      <h1>Why serverless</h1>
<p>2022-05-13</p>
<h2>概览</h2>
<p>基于响应式的，纯粹的，描述的业务逻辑执行模型（不限语言，环境），write once run any where&lt;br /&gt;参考： remix，qwik，nextjs，dva，redux，react hooks，axii，vue setup，Proxy</p>
<h2>现状</h2>
<p>纯粹的前端状态管理不行吗？有什么是redux和vuex，hooks解决不了的</p>
<p>不行的原因是：</p>
<ul>
<li>自主性不足，普通web应用的前端的状态管理是二手的，基于数据逻辑的再封装和再计算，重复劳动
<ul>
<li>导致现状：服务不存状态，角色分工
<ul>
<li>模型体现在数据库表里</li>
</ul>
</li>
<li>特定领域的重型前端应用呢？如编辑器
<ul>
<li>不是，UI侧数据模型，数据库表可能有或没有（存了原子操作</li>
</ul>
</li>
</ul>
</li>
<li>数据的能力不足，前端管理的是
<ul>
<li>GUI所依赖的临时缓存，如loading，交互状态的缓存</li>
<li>用户行为产生的数据，如输入，轨迹</li>
<li>待更新的数据草稿</li>
<li>server端返回的数据</li>
</ul>
</li>
</ul>
<p>因为数据的流向是 db -&gt; server -&gt; client，下游的持久化需求最终都依赖db手动的支撑</p>
<p>要解决的是：业务模型单元，纯函数逻辑，保持简洁和防止出错</p>
<ul>
<li>纯UI的状态
<ul>
<li>useState,
<ul>
<li>disabled</li>
</ul>
</li>
</ul>
</li>
<li>涉及服务
<ul>
<li>响应式
<ul>
<li>useRequest
<ul>
<li>loading</li>
<li>deps</li>
</ul>
</li>
</ul>
</li>
<li>命令式
<ul>
<li>sendRequest()</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>useRequest建立联系后就可以不管了，自动处理了订阅关系，包括loading。&lt;br /&gt;所有的state都视作数据 + 计算结果，都视作乐观更新，这是Read</p>
<p>Update，Remove，Create怎么解？</p>
<ul>
<li>手动
<ul>
<li>调用apis.Method().then( ...重新读取当前数据 )</li>
</ul>
</li>
<li>自动
<ul>
<li>赋值即create</li>
<li>修改属性则update</li>
<li>= null 则删除（删除比较危险，可以更“显性”一些</li>
</ul>
</li>
</ul>
<p>数据控制idea：由于编程 = 数据 + 指令，数据是指令的起点，指令的目的是生成下一份数据，&lt;br /&gt;异常表示程序指令无法正确的执行，通常是由于指令依赖的数据不及预期&lt;br /&gt;而逻辑则是一系列数据 + 指令的有序的集合</p>
<h2>数据 &amp; 计算 &amp;副作用</h2>
<p>之前在思考如何在serverless 避免处理客户端长连接的情况，然后长连接的逻辑一般都是写在 useEffect里的，即在函数里看来，由于长链接的场景只消费当前计算的结果，不会影响当前的计算结果，所以它可以视作一种副作用。&lt;br /&gt;而在SSR的过程中，也不会去处理副作用的逻辑，免得计算结果不一致。</p>
<p>对于“计算”而言，要拆解成3种：</p>
<ul>
<li>参数Context
<ul>
<li>原子参数</li>
<li>computed参数 （参数和参数之间的关系）
<ul>
<li>b = computed (a)</li>
</ul>
</li>
<li>明确数据的存储特性
<ul>
<li>state（内存，基本）
<ul>
<li>cache（缓存，服务端缓存 or 客户端缓存，内存更新后，同步更新缓存）
<ul>
<li>客户端缓存 or 服务端缓存
<ul>
<li>依据的是数据的逻辑依赖上下游
<ul>
<li>被Model依赖，服务端缓存</li>
<li>没有被Model依赖，客户端缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>model（DB，内存更新后，异步更新DB）</li>
</ul>
</li>
<li>更新策略问题（参考分布式系统的缓存和数据一致性问题）？
<ul>
<li>默认乐观更新（先更新缓存，再更新数据库）
<ul>
<li>先更新数据库，再更新缓存</li>
<li>先删除缓存，再更新数据库</li>
<li>先更新数据库，再删除缓存</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>输入计算 f（跟computed的差别在于是否有外部输入，即入参）
<ul>
<li>newContext =  f ( input , currentContext)</li>
<li>f 和 f之间的关系</li>
</ul>
</li>
<li>副作用 （基于上述2者的变化
<ul>
<li>context
<ul>
<li>before, after</li>
</ul>
</li>
<li>inputCompute
<ul>
<li>before, after</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-javascript">// V1
// V1
const serverlessUnit = {
  context: {
    a; new State(),
    b: new Cache()
    c: new Model('Entity')
  },
  init () {
    // init body
  },
  inputCompute: {
    inputCompute (arg) {
      const deps = init(contextDraft)
      // middle state ?
      return { result: newResult } 
    },
  },
  effect: {
    notify: [['result'] ,(prev, current) =&gt; {
      //sendToNotify()
    }],
    beforeCompute: [(prev, current) =&gt; {
      //sendToNotify()
    }, ['compute']],
  },
}

// V2
function serverlessUnit () {
  const a = useState()
  const b = useCache()
  const c = useModel('Entity')
  
  const d = computed(() =&gt; a().x + b().x)
  
  // must receive a parameter，有语义的合集
  // reducer的既视感
  const inputCompute = useInputCompute(async (parameter) =&gt; {
    // do something with draft：a,b,c
    
    // progress ? no 只有0，1的2种状态
    
    return { a, b, c } // commit draft
  })
  
  // before compute
  useEffect([(prev) =&gt; {
    // prev = [a, b, c]
  }, [inputCompute]])

  // after compute
  useEffect([[inputCompute], (prev) =&gt; {
  }])
  
  return { a,b,c, compute }
}
</code></pre>
<h2>对比 redux</h2>
<p>不同于redux的单向数据流思路，改变数据一定要dispatch(action）-&gt; reducer -&gt; state，因为整个unit的数据都是响应式的，所以如果要修改state可以更简单些</p>
<ul>
<li>直接修改</li>
<li>通过 inputCompute</li>
</ul>
<p>这2者好像是互相冲突的，简单来说外部的输入，一定得引发内部某个变量的修改才有意义，即入参最终是某个变量的某个值 。所以从效果来说 2者是等价的。但 inputCompute 还是有存在的必要，因为它可以存在“语义”，serverless最终目的是一个建设业务模型，所以保留计算合集并提供一个语意就很重要，这也是区别于它不是一个单纯的数据结构</p>
<p>原本的系统是个整体 + 纯函数逻辑，所以如果要修改unit，那必须有外部的参数输入才能引起变化。inputCompute也应该是响应式的，按照最新的调用进行执行。虽然中间不达预期，但至少达到了 最终一致性&lt;br /&gt;unit stack</p>
<ol>
<li>modify, a.x = 1
<ol>
<li>直接更新(1)</li>
</ol>
</li>
<li>start recomputed  d （耗时较久）</li>
<li>inputeComute (入参)
<ol>
<li>获取 d （旧的值，d还没计算完）</li>
<li>更新(2)</li>
</ol>
</li>
<li>end recomputed d
<ol>
<li>inputCompute重新计算</li>
<li>更新(3)</li>
</ol>
</li>
<li>结束</li>
</ol>
<p>是否要必要保留”直接修改“ ？如果去掉是不是会更加纯粹，同redux一样 compute -&gt; state？简单的场景下：&lt;br /&gt;page.value + 1 和 一个addPage(1) 在语义上没有区别</p>
<p>综合下来，最大的区别是响应式 + 依赖</p>
<h2>状态同步传输</h2>
<p>由于server端还是不保存状态，所以当进行计算时，会将所依赖的Context通过http传到server端，这样server就可以执行compute计算</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t12" name="t12" >
  <article>
    <div class="markdown-body">
      <h1>chrome &amp; v8源码探路</h1>
<p>2021-05-09</p>
<blockquote>
<p>冷知识：chromium的源码虽然也是git，但是托管在自建服务上的</p>
</blockquote>
<p>代码仓库：
<span class="inner-link" href="https://chromium.googlesource.com/chromium/src.git/">https://chromium.googlesource.com/chromium/src.git/</span></p>
<p>代码阅读器：
<span class="inner-link" href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/clipboard/;bpv=0;bpt=0">https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/clipboard/;bpv=0;bpt=0</span></p>
<p>需要学一点C++才能看得清楚明白</p>
<h2>目录结构</h2>
<ol>
<li><span class="inner-link" href="https://chromium.googlesource.com/chromium/src.git/+/refs/heads/main/third_party/">third_party/</span> 第三方
<ol>
<li>blink/ 排版渲染引擎（之前是webkit）</li>
</ol>
</li>
<li>v8/ 外链到v8自己的目录</li>
</ol>
<p>v8是js的runtime，但是在浏览器有很多的API，如DOM，fetch等其实并不在v8里面，这些代码大部分在blink里</p>
<p>如 navigator.clipboard相关方法就在</p>
<p><span class="inner-link" href="https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/modules/clipboard/clipboard_promise.h">https://source.chromium.org/chromium/chromium/src/+/main:third_party/blink/renderer/modules/clipboard/clipboard_promise.h</span></p>
<h2>阅读姿势</h2>
<ul>
<li>了解整体的生命周期
<ul>
<li>功能模块的职责</li>
<li>功能模块的之间的调用机制和调用关系</li>
</ul>
</li>
<li>针对具体功能再看具体代码
<ul>
<li>要区分多平台</li>
</ul>
</li>
</ul>
<p>（to be continued）</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t11" name="t11" >
  <article>
    <div class="markdown-body">
      <h1>自身编码的极限</h1>
<p>非业务代码，解决一个棘手数据驱动的动画问题，早10晚10，且在提前一天已经想得比较清楚的情况下</p>
<p>结论：约1000行不到的代码</p>
<p>写完后大脑基本宕机</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t10" name="t10" >
  <article>
    <div class="markdown-body">
      <h1>数据库&quot;全量”索引</h1>
<p>2022-04-28</p>
<p>在了解了一些服务端的高并发问题看到的，大部分都因为数据库会成为性能瓶颈，或者某些服务成为单点问题也&lt;br /&gt;是因为数据库。换句话说，有没有办法直接解决数据库的性能瓶颈问题</p>
<ul>
<li>数据库总是瓶颈
<ul>
<li>为什么数据库不能随意扩容</li>
<li>分布式系统的缺陷：CAP 定理</li>
</ul>
</li>
<li>为什么不给数据库的数据建索引和缓存
<ul>
<li>按需缓存，手动实现</li>
<li>全量索引的存储空间是指数级爆炸</li>
</ul>
</li>
<li>自动100%按需缓存
<ul>
<li>现有的开发模式是假定完全无信任
<ul>
<li>数据库/服务端系统的输入无法预测</li>
<li>面向未来拓展需要</li>
</ul>
</li>
<li>roi，只有量大之后缓存才划算
<ul>
<li>缓存的成本固定，扩容的成本线性，2者产生交叉后用缓存才划算</li>
</ul>
</li>
<li>是否缓存，实时性
<ul>
<li>依赖业务的需求来判断</li>
</ul>
</li>
</ul>
</li>
<li>重复计算问题
<ul>
<li>即时是完全相同的请求还是要耗费服务端计算和数据库查询</li>
</ul>
</li>
<li>纯函数的可能性
<ul>
<li>100%的覆盖度</li>
<li>输入可预测，可枚举</li>
</ul>
</li>
</ul>
<h2>人对数据的意图</h2>
<p>要想实现输入的可预测，必须能够全部枚举产品在面向用户的都提供哪些数据功能，如：</p>
<ul>
<li>查询教室的学生数量</li>
<li>更新学生的状态，更新教室</li>
<li>登录/注册/评论/发布topic</li>
<li>引入外部资源</li>
</ul>
<p>一个产品能提供的数据交互始终是有限的，可枚举，用户在使用产品的使用，他能做的输入操作也是有限，可预测。（ 除了“模糊搜索”的，但像搜索这种非常典型且垂直且通用的场景可以走另一套单独的技术方案）</p>
<p>所以一般的服务端提供的代码也是一个有限的集合，但我们的代码是专注于抽象的，我们在产品的程序开发中强调”抽象”就是为了在有限的代码里去承接尽可能多的功能，从而降低软件研发的成本。“复用”也是，降低的是下次研发的成本</p>
<p>现在的ER提供的只有CRUD以及相关的一些衍生方法，过于抽象，要想实现产品的提供的功能往往需要大量的中间计算。如果能够把中间空白补充上，那不是以后就不用再写基础的接口了，明显是yes，但是站在一个ORM框架的角度来看，这是不可能，因为它知道自己是被什么产品用了，不可能穷举。</p>
<h2>自定义类型</h2>
<p>参考了“存取能力设计”，意图往往跟数据的类型有相关性，在CRUD的基础上还可以加一层基于类型的操作，这个类型诸如有：</p>
<ul>
<li>颜色</li>
<li>日期</li>
</ul>
<p>除了常规的类型之外，还可以拓展自己的复杂类型，这有点类似业务层的底层通用接口</p>
<pre><code class="language-typescript">findByKey('color').whereIsWarm() // 查找暖色系
findByKey('money').equals('$1') // 查找等值于1美元
findByKey('schoolWorker').equals('teacher') // 找“老师”或班主任，递进关系
</code></pre>
<p>类型的解释权应该归对应的产品所有，相同的类型在不同的产品有可能对应不同的语义</p>
<p>但类型本身应该具备横向的功能，又能被功能层重新定义</p>
<h2>功能层抽象</h2>
<p>不同于类型的通用，功能层的抽象逻辑往往只注重于当前功能要解决的问题，只存在于整体功能的复用而不会是功能内个别代码的复用</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t9" name="t9" >
  <article>
    <div class="markdown-body">
      <h1>一个用户值多少钱</h1>
<p>2022-03-01</p>
<p>在互联网有这么一群人，他们不发帖不评论，几乎不生产任何内容，他们在网上留下的最重的动作可能就只是“点赞”和“关注”，很多从业者把这群人称作白嫖用户，他们在网上微不足道，但聚在一起却成了所有互联人求知若渴的“流量”</p>
<p>所以这里就有一个很矛盾的点，对于商业主体而言：</p>
<ul>
<li>成本
<ul>
<li>为了服务大量的普通用户，服务器成了大量的开销，是一个巨大负担</li>
</ul>
</li>
<li>利益
<ul>
<li>大量的普通用户汇聚在一起之后成了公司不可或缺的流量，公司需要这股流量进行变现，获得收入</li>
</ul>
</li>
</ul>
<p>经典的极端的2个方向，有矛盾那就说明有“边界”，越过这个“边界”让普通用户具备了超过“成本”的商业价值，使得商业主体获得利润</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t8" name="t8" >
  <article>
    <div class="markdown-body">
      <h1>小“闭环”体系</h1>
<p>2022-04-11</p>
<p>最近在思考前后端一体化单元时，想到了几种形式：框架，或者 语言形式，如果采用语言形式，需要设计一套新的DSL，如果使用声明式DSL，还可以在使用可视化编辑器 + DSL runtime，如果是过程式DSL，可以使用Web IDE 结合 代码生成，出码后得考虑是直接的代码，还是生成包含框架的代码，如果是框架是否可以使用最开始的框架</p>
<p>---- 上层</p>
<ul>
<li>UI
<ul>
<li>计算数据</li>
<li>原始远端数据</li>
</ul>
</li>
<li>serverless 中间抽象层</li>
<li>Model
<ul>
<li>原始数据</li>
<li>高性能缓存的数据</li>
</ul>
</li>
</ul>
<p>---- 下层</p>
<ul>
<li>底层：
<ul>
<li>框架
<ul>
<li>抽象概念</li>
</ul>
</li>
<li>语言
<ul>
<li>抽象概念</li>
</ul>
</li>
</ul>
</li>
<li>我的DSL
<ul>
<li>声明式
<ul>
<li>DSL可视化编辑器</li>
</ul>
</li>
<li>过程式
<ul>
<li>富文本编辑器</li>
</ul>
</li>
</ul>
</li>
<li>出码
<ul>
<li>中间产物 + runtime
<ul>
<li>底层的承接
<ul>
<li>框架</li>
</ul>
</li>
</ul>
</li>
<li>代码生成
<ul>
<li>底层的承接
<ul>
<li>语言</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t7" name="t7" >
  <article>
    <div class="markdown-body">
      <h1>关注&quot;读&quot;数据</h1>
<p>2022-04-24</p>
<p>原始的ORM是数据库的操作的映射，现在更进一步发展了像prisma这样的基于ER的操作，但是原始的CRUD和关联关系还是不够描述</p>
<p>在实现”版本“的过程中发现
写操作，可以针对id进行原子化操作，即写操作必须是完全建立“读”的基础上
读操作，才需要重点考虑各种复杂的拓展关系，既要满足查询的诉求，同时也要作为“写”操作的基础</p>
<p>读操作（R）可以拆解成几个步骤：</p>
<ul>
<li>参数
<ul>
<li>必须是精确描述</li>
<li>参数 不等于 “意图”</li>
<li>“函数”处理：求和，排序等</li>
</ul>
</li>
<li>运行查询
<ul>
<li>根据“Entity”来找数据</li>
<li>同时兼处理“函数”</li>
</ul>
</li>
<li>给出查询结果</li>
</ul>
<p>读（R）操作附带有查询和处理，由于现在的数据库都默认自带了一些“函数”逻辑，如排序，合并，所以很难意识到处理的部分，假设数据库不带这些函数，那么用户就必须在给出查询结果，再用额外的函数进行手动处理，手动处理的部分也是意图的一部分</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t6" name="t6" >
  <article>
    <div class="markdown-body">
      <h1>“搭建系统”的困境和突破</h1>
<p>2021-12-31</p>
<p>搭建系统是工具，工具是解决问题的，所以重点关注问题是什么，为什么搭建系统能解决。&lt;br /&gt;第二关注工具是怎么解决问题的，解决的结果如何。&lt;br /&gt;以及最后的剩下无法解决的问题怎么办？还有办法能解决吗？</p>
<p>基本纲要</p>
<ul>
<li>对齐认知
<ul>
<li>同步“目标”
<ul>
<li>业务
<ul>
<li>快速上线</li>
</ul>
</li>
<li>技术
<ul>
<li>原子化，沉淀复用</li>
<li>原子组件的开发体验要好：少概念，渐进增强</li>
</ul>
</li>
</ul>
</li>
<li>同步“搭建系统”的概念，定义，特点
<ul>
<li>面向非技术为主</li>
<li>NoCode</li>
<li>不需要可维护性</li>
</ul>
</li>
<li>同步个人的简单经历
<ul>
<li>美店</li>
<li>蚂蚁营销工作台</li>
</ul>
</li>
</ul>
</li>
<li>代入问题
<ul>
<li>能解决的问题域太小太垂直
<ul>
<li>有限的输入和组合只能解决更加有限的问题</li>
</ul>
</li>
<li>受上游影响极大
<ul>
<li>问题域内的是神器，问题域外的一文不值甚至负作用</li>
</ul>
</li>
</ul>
</li>
<li>对破局的思考
<ul>
<li>解决方向
<ul>
<li>广度
<ul>
<li>原子化，提升抽象，-&gt; 重新发明html，css，js</li>
</ul>
</li>
<li>深度
<ul>
<li>业务
<ul>
<li>需求不可控 -&gt; 需求全部适配 -&gt; 人力填坑 -&gt; 拓展边界 -&gt; 广度问题</li>
</ul>
</li>
<li>技术
<ul>
<li>极大增加搭建系统的数量 -&gt; 提升搭建系统的开发效率 -&gt; 搭建系统的搭建系统 -&gt; 搭建系统的基础物料 + 问题域定制</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>换个角度
<ul>
<li>卷往上游，以需求逻辑为中心
<ul>
<li>需求逻辑的描述是必须的，核心的，稳定的</li>
<li>需求逻辑是可流程化描述，如流程图</li>
<li>基于逻辑是可自动化</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>落地的结局
<ul>
<li>落地的困难
<ul>
<li>no，low，pro code之间的差异</li>
</ul>
</li>
<li>和解，放弃完全的NoCode，工程师你回来吧
<ul>
<li>重点解决其中的需求的确定性的部分
<ul>
<li>需求的确定性越高，需求的信息量就越大，编写程序就变得越简单，后续而二次消费也更容易</li>
<li>确定边界</li>
</ul>
</li>
<li>流程图变成填空题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>为什么搭建</h2>
<p>C端营销场景：技术服务业务，业务KPI。</p>
<ul>
<li>目标：业务KPI
<ul>
<li>承接：页面</li>
<li>目标：快速上线
<ul>
<li>承接：技术</li>
<li>目标：页面开发效率 （ 效率 = 工程师  * 页面代码 / 时间）
<ul>
<li>时间不变，提升工程师，提升页面代码</li>
<li>目标1：提升工程师
<ul>
<li>工程师很难提升，只能转移或者赋能
<ul>
<li>转到外包</li>
<li>降低门槛，让非工程师也能做</li>
</ul>
</li>
</ul>
</li>
<li>目标2：提升页面代码
<ul>
<li>代码不能凭空产生，要么由人(AI)编写，要么使用已经存在的代码
<ul>
<li>AI手段：各种 to code，Design to Code, Prd to Code, Flow to Code</li>
<li>代码封装，复用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>页面搭建系统是符合上述的2个目标的解决方案之一</p>
<h2>问题域</h2>
<p>搭建工具对应的问题域的特征：</p>
<ul>
<li>技术挑战类：
<ul>
<li>流量大，时效性强
<ul>
<li>活动特征，跟随大促节点</li>
<li>读远大于写入</li>
</ul>
</li>
<li>状态简单
<ul>
<li>流转关系可以通过逻辑流程图充分描述，并被一般人充分理解</li>
<li>状态枚举通常不会超过3个值（如 0/1, 0/pending/1,  pending/fulfiled/rejected）</li>
</ul>
</li>
</ul>
</li>
<li>业务价值类
<ul>
<li>无序
<ul>
<li>缺少统一标准（技术标准，产品标准）</li>
<li>缺少最佳实践，</li>
<li>反复验证，AB实验</li>
</ul>
</li>
<li>效率优先
<ul>
<li>开发资源不足</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>搭建系统最简单实现</h2>
<p>基本元素：</p>
<ul>
<li>有限规则的输入端
<ul>
<li>可视化</li>
<li>API</li>
</ul>
</li>
<li>中间抽象数据
<ul>
<li>DB</li>
<li>json</li>
</ul>
</li>
<li>输出端
<ul>
<li>runtime</li>
<li>生成代码</li>
</ul>
</li>
</ul>
<blockquote>
<p>page = runtime(json)</p>
</blockquote>
<p>假设现在已经用这个公式解决问题了。</p>
<p>这个过程的本质就是一个DSL，所以DSL的局限性也包含了这里说的“搭建系统”的局限性，同时我们狭义的页面搭建系统也有局限性。</p>
<h2>2个项目简介</h2>
<p>用“搭建”的思路解决问题的过程中，主要做过2个搭建系统，他们除了都叫搭建之外，剩下的技术实现不同，用户不同，解决的问题也不同：</p>
<ul>
<li>电商营销会场H5页面搭建
<ul>
<li>平台用户：
<ul>
<li>万千电商运营</li>
</ul>
</li>
<li>技术架构：
<ul>
<li>react + jquery</li>
<li>java模版 + ssr</li>
<li>搭建组件 = React组件 + 组件的描述 + 定制编写的编辑区</li>
</ul>
</li>
<li>搭建能力：强
<ul>
<li>私有组件标准，组件之间可以嵌套，组合</li>
<li>线性布局，绝对定位布局，且能相互组合</li>
</ul>
</li>
<li>页面不需要可维护性</li>
</ul>
</li>
<li>花呗营销活动H5页面搭建
<ul>
<li>平台用户：
<ul>
<li>花呗运营</li>
<li>专业前端</li>
</ul>
</li>
<li>技术架构：
<ul>
<li>全栈中中台（react + eggjs + mysql）</li>
<li>CDN html + 异步接口</li>
<li>组件拓展性强</li>
<li>搭建模块等价于React组件</li>
</ul>
</li>
<li>搭建能力：弱
<ul>
<li>相当于 Array&lt;React.Component&gt; 的一维数组</li>
</ul>
</li>
<li>页面不需要可维护性</li>
</ul>
</li>
</ul>
<p>总结特点：</p>
<ul>
<li>核心目标是：效率
<ul>
<li>相同的模块标准，便于沉淀复用</li>
<li>充分灰度，快速上线</li>
</ul>
</li>
<li>NoCode
<ul>
<li>低门槛，少概念</li>
<li>非技术为主</li>
</ul>
</li>
<li>不在乎产物的可维护性和可拓展性</li>
</ul>
<p>可以看到这里做的2个搭建系统他们是相似又不相同：</p>
<ul>
<li>相似的：
<ul>
<li>营销，活动，</li>
<li>一次性，</li>
<li>低门槛</li>
<li>一套组件标准</li>
</ul>
</li>
<li>不同的：
<ul>
<li>使用者逻辑水平，</li>
<li>页面可交互复杂度</li>
<li>平台搭建能力</li>
</ul>
</li>
</ul>
<p>这么相似能不能在保留核心的特性下只加一点的改造就能互换一下在对方的业务里直接使用呢？不能。因为环境，需求的不同导致了平台之间有显著差异，所以不能。</p>
<p>那有没有可能一个搭建系统就能解决2个业务呢？那肯定能，因为站在现在的视角来看，需求已经确定成产品了，只要再统一一下抽象就行。</p>
<p>合并：提升抽象，提升复杂度</p>
<ul>
<li>搭建能力对齐，都支持多布局</li>
<li>组件标准升级，私有标准</li>
<li>按业务域划分租户，分隔平台用户</li>
</ul>
<h2>解决之后</h2>
<p>往广度思考：&lt;br /&gt;一个搭建系统只能解决一个垂直域的问题，如果要跨垂直域，那就意味着要把提升搭建系统的抽象程度，拆解一下把视图结构的用一种DSL，样式的部分用一种DSL，逻辑的部分再用一种DSL 。（黑人问号，重新发明一下html，css，JavaScript ？</p>
<p>往业务的深度思考：&lt;br /&gt;除了无法跨域，而且针对搭建系统的上游：需求，逻辑，无法充分收敛。因为上层是完全不可控的，即当技术侧发起的工具/服务无法解决满足上层需求时，就只剩下2个解法：</p>
<ul>
<li>人力填坑</li>
<li>需求变形</li>
</ul>
<p>这2个解法都会出问题</p>
<p>人力填坑相当于开了外挂，一旦开启则无法停下，搭建系统迅速失控名存实亡，沦为鸡肋，其存在的就变成了问题本身。</p>
<p>需求变形，即需求适应系统的短板，站在更上层的视角看，这是对业务的不可避免的伤害。</p>
<p>往技术的深度思考：&lt;br /&gt;如果一个搭建无法高效的解决全部问题，那就增多搭建系统的数量，创建能搭建搭建系统的高阶搭建系统，抽象搭建系统本身的组成：输入，中间数据，页面。那么，搭建系统的抽象如何拆解，</p>
<p>搭建系统A -&gt; 问题域X&lt;br /&gt;搭建系统B -&gt; 问题域Y</p>
<p>高阶搭建系统X -&gt; A, B -&gt; X, Y</p>
<p>如果：这时候来了新需求Z1，新需求Z1属于问题域Z。（比如：营销人传人）</p>
<p>如果A，B不能满足Z1，解决问题Z，那为什么X能解决问题Z ？可能性🈶2：</p>
<ul>
<li>X很先进，提前预判到了Z的存在
<ul>
<li>如何预判？怎么收集需求</li>
</ul>
</li>
<li>X很灵活，有拓展机制能够让开发者继续开发解决Z
<ul>
<li>本质是劳动力的转移（需要拓展多少？有没有可能是完全重写，那就X不就成了基础框架）</li>
<li>问题Z = 新需求Z(1-&gt; Infinity)  = ( 新搭建系统 =  高阶搭建系统 + 人力procode )
<ul>
<li>反问：如何衡量ROI，为什么不简化为“人力procode -&gt; 新需求Z0”，</li>
<li>反问2：再来个新的W问题如何？上游不可控</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2>如何突破</h2>
<p>看流程，视角也许可以从技术侧前移，看看能不能从需求侧解决，俗称：如果解决不了问题，可以尝试换个问题，看看在这整个过程，最核心的点是什么。不是最初的业务目标，而是基于目标描述的业务逻辑。</p>
<p>来自运营的需求目标： 1.提升MAU， 2.有一亿的预算，3.其它指标等&lt;br /&gt;产品分析之后并输出之后形成产品PRD：里面描述了产品逻辑，最后开发面对的是这一整套产品逻辑，包含用户，行为，状态事件，最后形成页面。</p>
<p>但是在搭建页面的这些逻辑被分散到各个组件里，经典的场景：在评审需求往往会有一个流程图，但在页面完成后这个流程图就没用了。</p>
<p>再深入一点，充分的把流程图用起来，让静态的流程图动起来。</p>
<p>建设以“逻辑编排”为核心的搭建体系，</p>
<h2>以“逻辑”为中心</h2>
<p>2个需求示例：日常花呗抽奖活动，花呗五周年小纸条</p>
<p>以流程图为中心，流程图里要包含的基本结构：</p>
<ul>
<li>生命周期上下文
<ul>
<li>内置变量，</li>
<li>内置常量，</li>
<li>基础自定义数据，如
<ul>
<li>
<pre><code>营销规则，人群规则
</code></pre>
</li>
<li>开始时间，结束</li>
</ul>
</li>
</ul>
</li>
<li>基本结构字段
<ul>
<li>人物等客观条件，Value Object
<ul>
<li>时间，</li>
<li>某个业务实体（物品，优惠券）</li>
</ul>
</li>
<li>计算节点
<ul>
<li>分支判断</li>
<li>用户行为事件响应（通常是点击，浏览</li>
</ul>
</li>
<li>渲染节点
<ul>
<li>渲染
<ul>
<li>渲染整个页面，页面是搭建来的</li>
<li>渲染局部，如弹框</li>
</ul>
</li>
<li>等待事件
<ul>
<li>等待渲染的UI 抛出事件（用户行为，自定义描述的事件）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>拓展信息：
<ul>
<li>逻辑覆盖率</li>
<li>监控</li>
<li>埋点</li>
<li>流量分布</li>
<li>自动化压测</li>
<li>自动化性能优化</li>
<li>业务转化率，漏斗，采集</li>
</ul>
</li>
</ul>
<h2>逻辑怎么不行了</h2>
<h3>示例1：抽奖</h3>
<h3>示例2：小纸条翻页</h3>
<p>1.是纯前端视角，格局没有打开</p>
<p>2.可覆盖的复杂度不够</p>
<p>“动态  &amp; 前后可翻动的小纸条”让我破了防</p>
<p>NoCode无法覆盖纯逻辑的部分，但是NoCode依然保留有能力无限且复杂的逻辑确定下来。</p>
<p>对业务来说可以是一个黑盒，黑盒只暴露接口，“动态  &amp; 无限可翻动的小纸条”有2个接口：翻页完成，翻页退出，借助Code的手段从而完成降维</p>
<p>和解，放弃完全的NoCode，重点解决其中的需求逻辑的确定性的部分</p>
<p>需求逻辑的确定性越高，需求逻辑的信息量就越大，编写程序就变得越简单，后续而二次消费也更容易，流程图变成填空题</p>
<p>3.无法很好的处理循环和循环退出&lt;br /&gt;拓展一下，即语义的逻辑和实际的程序逻辑不是一一一对应的，中间是有抽象的，如：</p>
<blockquote>
<p>点击tab offset=0 -&gt; getList
点击pagination offset+=1 -&gt; getList
程序：任意点击行为，offset changed -&gt; getList(offset)</p>
</blockquote>
<p>而且语义的逻辑经常会默认带一下脑内上下文，比如点击tab，默认就清空了前面的变量，或者意识人，非技术人员通常会分别 每个tab都是独立的逻辑，而程序逻辑则可能是为了性能，默认复用变量</p>
<h2>逻辑的边界</h2>
<p>当我意识到在逻辑上的产品经理（或需求方）不应该去关注如何底层的程序细节时，同时让产品描述逻辑是可行的，那就说明在这个产品 -&gt; 逻辑的路径上存在一个边界。</p>
<p>最先开始：产品 -&gt; 需求 -&gt; 工程师 -&gt; 逻辑</p>
<p>原本的设计：产品经理 -&gt; 逻辑（这里的逻辑即包含了业务逻辑和程序逻辑，同时工程师参与但也负责逻辑的正确性，完备性，逻辑有问题就如同需求有问题，如同程序出了bug）</p>
<p>业务逻辑一定包含程序逻辑，但反过来程序逻辑不一定是业务逻辑。（参照声明式编程和指令式）</p>
<blockquote>
<p>转账 = move(A.balance,B.balance)
借钱 = move(A.balance,B.balance)</p>
</blockquote>
<p>加入工程师之后的设计：产品经理 -&gt; 业务逻辑（声明式，关心用户，UI，业务状态） -&gt; 工程师 -&gt; 程序逻辑（类库或接口， 复用或者新开发，按业务逻辑进行填空，关心数据，稳定性）</p>
<p>当考虑到工程师角色参与之后，我意识到这个“边界”不是一个确定性静态的值，它应该是工程师和产品在认知上达成的统一共识，而且会随着产品不停迭代动态变化。“边界”的作用不再是对立性的，而是为了寻求最佳的解法。</p>
<p>再进一步抽象一下：</p>
<blockquote>
<p>产品 -&gt; 结构化后的需求 -&gt; 工程师 -&gt; 代码</p>
</blockquote>
<h2>结局</h2>
<p>一个瑕疵明显的NoCode方案，不容易打动人心，落地阻力大。</p>
<p><s>人们</s>工程师们对于NoCode和ProCode有很高的质疑，但对于lowCode则很包容</p>
<ul>
<li>no code表面太完美，工程师天然直觉认为必定非code不可解决的地方，这将来是一个深坑</li>
<li>pro code本就是工程师的专业领域，这是专业领域的碰撞，语言只有2种被人喷的和没人用的</li>
<li>low code 则取决于视角和比例
<ul>
<li>观点1：low的部分是帮助工程师减轻负担</li>
<li>观点2：code的部分是增加了工程师的负担</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t5" name="t5" >
  <article>
    <div class="markdown-body">
      <h1>前端的边界</h1>
<p>2022-04-11</p>
<blockquote>
<p>探索一下”前端“这个岗位在技术，职能的天花板</p>
</blockquote>
<h2>背景</h2>
<p>由“模型”中心衍生想到的，当我在尝试实践remix时，remix这种完全以form表单为中心，action处理的方式，跟很早之前的MVC（php，java servlet，其中的主要差别在于remix通过编译手段暴露很多中间状态，改善UI渲染，不能说很像，只能说是极其类似。</p>
<p>参考这个方式会突然想到，古典的MVC是很不适合做复杂前端应用的，所以remix也许这样，但为什么不适合</p>
<p>另外前端是从后端里产生的，但是为什么后端要把这个工作分离出来，仅仅是有人说的因为“后端不想干这个脏活累活”吗？</p>
<h2>还原一下</h2>
<p>如果不考虑其它因素，真的完全用php可以实现复杂前端应用吗？比如绘图工具，编辑器工具。明显地，应该是可以实现的，</p>
<p>比如把原本的js里的状态变量都设定为数据库表或者redis，每一次用户的行为都会触发form或ajax请求，在controller里处理状态并落库，之前刷新页面，重新读取数据库里的数据，最后渲染到页面</p>
<p>相比现在的前后端分离的模式，在技术唯一的差别：</p>
<ul>
<li>将原本的前端状态持久化到了数据库</li>
<li>确保前端UI是完全受控于数据库</li>
</ul>
<p>那么在这2个条件下，就能用后端实现一个完全复杂的编辑器应用，前端作为视图层需要完全的渲染HTML即可，如果使用form表单来提交数据，确实甚至都不需要js执行</p>
<h2>为什么不</h2>
<p>既然上述的方式存在确实可行，但现实是还是发生了拆分了，那到底是什么因素导致的呢？首先看下上面的弊端，统一在一起之后</p>
<ul>
<li>对人
<ul>
<li>素质要求变高，写的人必须同时写MVC</li>
<li>身兼多职，无法深入研究和解决单一领域问题</li>
<li>单点问题，一个人从头撸到尾容易成为瓶颈，工业化生产讲究分工协作，</li>
</ul>
</li>
<li>对事
<ul>
<li>数据冗余，很多用户的临时操作状态都必须存在数据库里，如果要节约资源就加上及时清理机制</li>
<li>体验不流畅，每步操作都必须走网络请求到服务端，链路长，响应时间久</li>
<li>计算资源浪费，状态的流转都必须借助服务端CPU，浪费了用户客户端的计算能力</li>
<li>耦合问题，全流程绑定到了一起，无法局部复用，无法提升后续效率</li>
</ul>
</li>
</ul>
<p>也许还有更多原因，但总结大体是2个因素导致了现状：</p>
<ul>
<li>（降本）节约（服务器）计算资源</li>
<li>（增效）生产效率</li>
</ul>
<p>降本：</p>
<ul>
<li>将临时状态，用户状态转移到前端内存或浏览器缓存，减少存储</li>
<li>状态的切换转移在js里计算，减少计算和网络请求</li>
<li>由于上述的操作，状态的存取都在用户内存里进行，响应加快，也间接的导致了体验变好</li>
</ul>
<p>增效</p>
<ul>
<li>分离产生的分工，专业的人做专业的事情，前后端分别负责V，C和M，在单点里提升专业度和效率</li>
<li>复用成为可能，由于分离后各自成为单独的抽象层，使得层的复用成为可能</li>
</ul>
<h2>边界的产生</h2>
<p>在分离后，并且随着互联网大发展，前后端在各自的领域里狂奔，在今天去区别一个前后端的人已经不是用“编程语言”来区分了，用js或java并不重要，重要前后职能的人在自己领域内的重点问题的探索，思考，实践，如：</p>
<ul>
<li>前端
<ul>
<li>生产力工具：低代码，web ide，富文本编辑器，各类平台</li>
<li>多端程序：DSL，跨多端多平台，小程序，BFF(SSR，serverless函数计算）</li>
<li>传统视图特色：Web GL，A/VR，游戏引擎</li>
</ul>
</li>
<li>后端：
<ul>
<li>计算性能：高并发，大数据，多媒体处理</li>
<li>存储：各种数据库，中间件，缓存，云盘</li>
<li>devops：容器虚拟，云原生</li>
<li>（列举不全，参考阿里云，腾讯云卖的各种产品）</li>
</ul>
</li>
</ul>
<p>以上只是一些举例，当然还有很多没列举到的。由于前后端在区分的边界上已经更注重于问题领域的差别，而不是手段或者工具，所以熟练的掌握一些工具的经验可以帮助我们更好的探索问题域，但不能本末倒置的沉迷在工具里，不需要再问“学react还是vue”这种问题了</p>
<h2>回顾一下更早的历史</h2>
<p>在最原始的时期，那时候连后端都没有，古典时期的程序员们就是直接面向数据库（计算机的本地的存储数据）开发，通过接收原始的输入存储，然后通过指令文本打印到命令行界面：</p>
<blockquote>
<p>命令行文本 &lt;--- 程序处理 &lt;--- 存储的数据</p>
</blockquote>
<p>在传统架构下，计算机仅需考虑用户本地的情况下，当互联网产生的时候，C/S架构也产生了，命令行界面的数据不一定来自于本地，也有可能来自于其它ip的计算机，其它ip的作为数据和计算服务提供者，才称作服务器。逐步逐步演进到今天后，随着问题的解决，以及新的问题越来越大越复杂。</p>
<p>为了适应这种变化，职能的分工也就陆续产生了，虽然职能诞生了，但会发现整个程序的基本模式并没有大变化，变化的是每个流程里不断的细化分工，不断提升的是整个系统的计算能力，输出（传输）能力，存储能力</p>
<blockquote>
<p>输出（多端） &lt;--- 中间处理（服务器架构或客户端）&lt;--- 底层数据（集群）</p>
</blockquote>
<h2>面向更极致的未来</h2>
<p>由于基础设施的完善，生产力工具的爆炸，以及人员素质的提升，也许使得一个人已经可以负担足够多的复杂度。想想看，现在写一个登陆系统，博客系统比之前的时代有了多了多的提升。</p>
<p>继续迭代生产力工具，提升抽象，降低对用户的复杂度，使得之前的复杂应用降维成了现在的简单应用。</p>
<p>所以在今天的场景里，也许已经有办法让一个人或一个职能去负担一个完整且复杂的应用，如果有一个种新的工具具备描述一个完整的功能，通过功能的叠加和组合，再去诞生出一个应用。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t4" name="t4" >
  <article>
    <div class="markdown-body">
      <h1>以“模型”为中心</h1>
<p>2022-04-08</p>
<blockquote>
<p>不想再写一次登录系统了</p>
</blockquote>
<h2>Nextjs</h2>
<p>深度使用nextjs后的感悟，发现nextjs这种以serverless为中心的设计复用的，以路由即页面</p>
<p>这样的问题是由于serverless缺少模型的信息，导致在业务逻辑就只能在前端UI的逻辑里面处理，同时在设计时，需要区分前端的状态和模型的字段</p>
<p>这导致的一个问题，设计书写一个完整功能是被分割成了3个地方：ER模型，serverless或前端处理逻辑，UI</p>
<p>在架构上就处于3横多纵的模式，这样的好处是相同层容易互相复用逻辑（耦合），局部的横向造成了耦合，但却无法整体导出</p>
<p>如果以模型为中心，只构建纵向，横向的建联通过直接的引用。</p>
<pre><code class="language-typescript">// module2.jsx
import { useApi: useApi1, Component } from 'module1.jsx'

export function useApi () {
  const use1 = useApi1()
  return {
    findFoo () {    
      use1.findAndDoSomething('')
    }
  }
}

export function Component () {
  return (
    &lt;newDialog&gt;
      &lt;Component /&gt;
    &lt;/newDialog&gt;
  )
}
</code></pre>
<p>这样的模型，severless，UI为组合，那就像之前的MVC架构， M -&gt; C -&gt; V -&gt; C -&gt; M的流程</p>
<p>这里有个问题，当M -&gt; C -&gt; V之后，其实在V层面已经收到了来自于C层经过计算之后得到的状态，为什么当状态修改的时候，还需要显示的调用 V -&gt; C -&gt; M 把数据再还原回去呢，为什么不能逆向计算后，直接 V -&gt; M？</p>
<ul>
<li>不是所有的计算都是可逆的，那哪些计算可逆？</li>
<li>也不是所有的V都需要直接到M，有些是临时状态需要缓存，如何显示的区分这些状态</li>
</ul>
<h3>发散</h3>
<p>http server 是无状态的或者只缓存状态，模型里只保存最原始的数据或者为了性能考虑保存需要大量计算的数据或索引</p>
<ul>
<li>怎么判断哪些状态字段需要持久到模型中？
<ul>
<li>如状态不存在模型中，那么模型到状态之间总是需要一个计算，好像是serverless不可缺少？</li>
</ul>
</li>
<li>“状态”如何在 server/website 中同步 ？</li>
</ul>
<h2>前后一体化单元</h2>
<p>实现一个功能最小单位至少包含：UI，serverless或useHook，Model ，（其中UI和model至少有1个）</p>
<blockquote>
<p>另外的场景：单独的后端很少会讲到复用，但当说到复用的时候，系统负责的领域足够大时，这就成了“中台”</p>
</blockquote>
<ul>
<li>没有Model
<ul>
<li>静态站点，博客</li>
<li>Sketch，PS工具（广义来说，ps文件作为输入，也应视作Model）</li>
</ul>
</li>
<li>没有UI
<ul>
<li>API gateway（这种是中间件，这个好像Model也没有，但这个不够广泛</li>
<li>CDN服务，Open API服务，各种后端服务系统</li>
</ul>
</li>
</ul>
<p>在不考虑“用户”的情况：Model最重要，数据是资产&lt;br /&gt;在考虑“用户”的情况下：UI最重要，能用和好用</p>
<p>一体化单元之间的互相组合有2种形式：</p>
<ul>
<li>静态，需要版本管理
<ul>
<li>就像类库的引入，之后2个单元就是相同的工程，
<ul>
<li>问题：model层是一个大集合，同时无法拆分，存储成本</li>
</ul>
</li>
</ul>
</li>
<li>动态，需要运行时
<ul>
<li>就像微服务或中台，引入的其实是SDK，2个单元不能算是一个有机的整体，只是允许互相调用的服务
<ul>
<li>问题：model层会成为单点</li>
</ul>
</li>
<li>一旦动态之后就需要：服务的发现，注册，订阅，销毁等生命周期，</li>
</ul>
</li>
</ul>
<p>一体化单元要暴露的是：</p>
<ul>
<li>Serverless或hook</li>
<li>UI</li>
</ul>
<p>微服务</p>
<ul>
<li>持久层隔离
<ul>
<li>底层Model之间的关系的引用和处理，跨数据库，这个怎么索引和建联？</li>
</ul>
</li>
<li>公用Model
<ul>
<li>单点问题</li>
<li>大表索引问题</li>
</ul>
</li>
</ul>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t3" name="t3" >
  <article>
    <div class="markdown-body">
      <h1>快速理解next.js</h1>
<p>2022-03-17</p>
<p>最近尝鲜真正投入在业务场景里使用了下nextjs，但在刚开始用不久，就产生了一个疑问：</p>
<blockquote>
<p>想在next.js 初始启动的时候去连接数据库，应该怎么做呢？</p>
</blockquote>
<p>在参考了官方示例之后（<span class="inner-link" href="https://github.com/vercel/next.js/tree/canary/examples/with-mongodb">https://github.com/vercel/next.js/tree/canary/examples/with-mongodb</span>）</p>
<p>我有点悟了，发现完全误解了nextjs的真正形态，简单来说：nextjs不是一个带了node服务的前端框架，而是一个集成加强型view的node server</p>
<p>上述的疑问背后的真正问题是：我不了解nextjs，我在尝试寻找nextjs的server的“入口”，而实际上nextjs整个就是server</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t2" name="t2" >
  <article>
    <div class="markdown-body">
      <h1>探寻Low Code</h1>
<p>2022-01-16</p>
<h2>概览</h2>
<p>low code（包含no code）一种通过提高抽象，隐藏程序细节的方式而设计出来的面向具体业务（领域）的平台工具，其目标一般是提效（原本角色做的更快更不容易出错）或者赋能（能做他们本做不到的事情）</p>
<p>在公司平台里有大大小小不同的low code平台，针对不同的业务域问题，设计了不同的组件，服务系统，接口，可视化界面等等，然后在自己的业务域里不断迭代着</p>
<p>但是这些low code系统在往往只根据具体问题，设计了具体功能，现有的技术进行代码堆砌，最终出来一个“平台” ，但背后的底层抽象却鲜少提及。</p>
<h2>回溯历史</h2>
<p>我们现在每天接触的JavaScript，java等，通通都是称为高级语言，在高级语言之下的是低级语言，如汇编，机器语言。现在已经不再写汇编了，我们已经可以通过更高抽象的高级语言来完成工作，因为这样更加高效也更准确。所以高级语言某种意义上也是一种low code。</p>
<p>但光有在JavaScript还不够，还不够快，通过语言的特性，上面诞生了各种各样的UI框架，vue，react。这些框架也通过更加高级的抽象，改变了前端工程师的开发方式。这也是一种low code。</p>
<p>在UI框架之上，还有更上层的抽象，如remix，next.js等，通过引入服务端的能力，让前端工程师的技术的纵深又深了一步而且学习的成本很低。</p>
<p>可以看到随着时代的发展，在编程界的工具都是不断提升的抽象，而且领域越来越细分
<img src="./2_1.png" alt="抽象层次"></p>
<h2>一个有意思的问题</h2>
<p>问题：搭建系统的搭建系统（高阶搭建系统）是否有存在的意义？</p>
<p>辅助说明：只通过提供 library 的方式不能算高阶搭建系统
抽象程度：高阶搭建系统 &gt;  搭建系统，
问题域范围：高阶搭建系统 &gt; 单个搭建系统，但 高阶搭建系统 &gt;=  子搭建系统的并集</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t1" name="t1" >
  <article>
    <div class="markdown-body">
      <h1>图形开发</h1>
<p>2020-08-10</p>
<p>前端本质是一个图形开发的子类，而图形开发最终，最高级的形态应该就是游戏，3A游戏。</p>
<p>一个成功的游戏应该是要涵盖图形技术，编剧，音乐，美术，交互互动，是各大类型技术的集大成者。图形开发虽然只是其中的一个分支，但它是其它分支表达的出口，就像小数点前面的1。</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
<a class="a-link" href="#t0" name="t0" >
  <article>
    <div class="markdown-body">
      <h1>流程化系统设计</h1>
<p>2019-09-15</p>
<h2>描述</h2>
<p>流程化的执行，是一个中心化的调度者。通过流程 + 服务调用的能力，可以把各种各样的服务进行串联的系统。</p>
<h2>节点树 + 执行器</h2>
<p>中心系统的前端UI界面经过用户的意志产生了节点树（Node Tree），上传到系统中，执行器（Runtime）去执行对应的节点树（Node Tree），就像手写js代码，然后放到服务器node环境中执行一样。</p>
<h2>标准服务模块</h2>
<p>中心系统本身基本没有服务的能力，只能执行流程，调用服务。所以外围注册的服务模块的决定了流程系统的上限。就像nodejs调后端接口一样</p>
<p>整个体验的过程就像是可视化编程一样，程序 = 逻辑 + 服务 + 执行</p>

    </div>
  
    <div class="mark">Y</div>

  </article>
</a>
  </main>
</body>
<script src="./content-script.js" ></script>
</html>

